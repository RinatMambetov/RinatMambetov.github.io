<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-10-08T20:38:21+03:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Мой блог о программировании</title><subtitle>Dive into the world of programming with my latest blog post</subtitle><author><name>Ринат Мамбетов</name></author><entry><title type="html">Руководство по Log4j и файлу log4j.properties в Java</title><link href="http://localhost:4000/java/logging/log4j/2024/07/05/java-log4j-properties-guide.html" rel="alternate" type="text/html" title="Руководство по Log4j и файлу log4j.properties в Java" /><published>2024-07-05T18:18:05+03:00</published><updated>2024-07-05T18:18:05+03:00</updated><id>http://localhost:4000/java/logging/log4j/2024/07/05/java-log4j-properties-guide</id><content type="html" xml:base="http://localhost:4000/java/logging/log4j/2024/07/05/java-log4j-properties-guide.html"><![CDATA[<p>Log4J — это популярный фреймворк для логирования с открытым исходным кодом, написанный на Java. Log4j широко используется в различных приложениях на Java. Более того, он является потокобезопасным, быстрым и предоставляет иерархию именованных логгеров. Log4j распространяется под лицензией Apache Software License с открытым исходным кодом.</p>

<p>Версия Log4j 1.x достигла конца своего жизненного цикла 5 августа 2015 года. Поэтому на сегодняшний день Log4j2 является последним обновлением Log4j.</p>

<p>В этом руководстве мы изучим Log4j и как настроить основные компоненты Log4j с помощью файла log4j.properties в Java.</p>

<h2 id="1-настройка-maven">1. Настройка Maven</h2>

<p>Для начала нам понадобится зависимость log4j-core в нашем файле pom.xml:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.apache.logging.log4j<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>log4j-api<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>2.24.1<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div>

<h2 id="2-api-log4j">2. API Log4j</h2>

<p>API Log4j предоставляет механизм для передачи информации о логировании на основе различных уровней приоритетов и направления её в различные назначения, такие как файлы, консоли, базы данных и т. д. Он также поддерживает фильтрацию лог-событий перед их передачей логгерам или аппендерам.</p>

<p>API Log4j имеет многослойную архитектуру, которая предоставляет два типа объектов в фреймворке Log4j — основные объекты и вспомогательные объекты.</p>

<h2 id="3-компоненты-log4j">3. Компоненты Log4j</h2>

<p>Существует три основных компонента Log4j — логгеры, аппендеры и макеты — которые могут использоваться вместе для вывода настраиваемых лог-сообщений в нужные назначения. Давайте рассмотрим их кратко.</p>

<h3 id="41-логгер">4.1. Логгер</h3>

<p>Объект Logger отвечает за представление информации о логировании. Это первый обязательный уровень в архитектуре Log4j. Класс Logger определён в пакете org.apache.log4j.</p>

<p>Как правило, мы создаём один экземпляр Logger для каждого класса приложения, чтобы логировать важные события, относящиеся к этому классу. Также мы обычно создаём этот экземпляр в начале класса, используя статический фабричный метод, который принимает имя класса в качестве параметра:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Logger</span> <span class="n">logger</span> <span class="o">=</span> <span class="nc">Logger</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="nc">JavaClass</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</code></pre></div></div>

<p>Затем мы можем использовать различные методы класса Logger для логирования или вывода важных событий в зависимости от их категорий. Эти методы включают trace(), debug(), info(), warn(), error(), fatal(). Эти методы определяют уровень запроса на логирование.</p>

<p>Приоритетный порядок методов Logger: TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL. Таким образом, эти методы выводят лог-сообщения в зависимости от уровня логгера, установленного в файле log4j.properties. Это означает, что если мы установим уровень логгера как INFO, то все события INFO, WARN, ERROR и FATAL будут записаны в лог.</p>

<h3 id="42-аппендер">4.2. Аппендер</h3>

<p>Аппендер обозначает назначение вывода логов. Мы можем выводить логи в несколько предпочтительных мест с помощью Log4j, таких как консоль, файлы, удалённый сокет-сервер, база данных и т. д. Мы называем эти выходные назначения аппендерами. Более того, мы можем прикрепить несколько аппендеров к логгеру.</p>

<p>Аппендеры работают в соответствии с правилом аддитивности аппендеров. Это правило гласит, что вывод лог-сообщения любого логгера будет направлен ко всем его аппендерам и его предкам — аппендерам, которые находятся выше в иерархии.</p>

<p>Log4j имеет несколько аппендеров, определённых для файлов, консольных выводов, GUI-компонентов, удалённых сокет-серверов, JMS и т. д.</p>

<h3 id="43-макет">4.3. Макет</h3>

<p>Мы используем макеты для настройки формата лог-сообщений. Мы можем сделать это, ассоциировав макет с уже определённым аппендером. Таким образом, комбинация макета и аппендеров помогает нам отправлять отформатированные лог-сообщения в нужные назначения.</p>

<p>Мы можем указать формат лог-сообщений, используя шаблоны преобразования. Класс PatternLayout объясняет больше о символах преобразования, которые мы можем использовать в зависимости от наших нужд.</p>

<p>Мы также рассмотрим несколько символов преобразования через примеры в следующих разделах.</p>

<h2 id="5-файл-log4jproperties">5. Файл log4j.properties</h2>

<p>Мы можем настроить Log4j с помощью XML или файла свойств. Файл log4j.properties хранит конфигурации в виде пар “ключ-значение”.</p>

<p>Имя файла конфигурации свойств log4j по умолчанию — log4j.properties. Логгер ищет это имя файла в CLASSPATH. Однако, если нам нужно использовать другое имя конфигурационного файла, мы можем установить его с помощью системного свойства log4j.configuration.</p>

<p>Файл log4j.properties содержит спецификации аппендеров, их имена и типы, а также шаблоны макетов. Он также содержит спецификации о корневом логгере по умолчанию и его уровнях логирования.</p>

<h2 id="6-синтаксис-файла-log4jproperties">6. Синтаксис файла log4j.properties</h2>

<p>В общем файле log4j.properties мы определяем следующие конфигурации:</p>

<ul>
  <li>Корневой логгер и его уровень. Мы также предоставляем имя для аппендера здесь.</li>
  <li>Затем мы назначаем действительный аппендер для определённого имени аппендера.</li>
  <li>Наконец, мы определяем макет, цель, уровень и т. д. для определённого аппендера.</li>
</ul>

<p>Давайте посмотрим на синтаксис общего файла log4j.properties:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Корневой логгер с именем аппендера
log4j.rootLogger = DEBUG, NAME

# Назначаем NAME действительный аппендер
log4j.appender.NAME = org.apache.log4j.FileAppender

# Определяем макет для NAME
log4j.appender.NAME.layout=org.apache.log4j.PatternLayout
log4j.appender.NAME.layout.conversionPattern=%m%n
</code></pre></div></div>

<p>Здесь NAME — это имя аппендера. Как уже обсуждалось ранее, мы можем прикрепить несколько аппендеров к логгеру, чтобы направлять логи в разные назначения.</p>

<h2 id="7-примеры">7. Примеры</h2>

<p>Теперь давайте разберём конфигурации файла log4j.properties для различных аппендеров с помощью нескольких примеров.</p>

<h3 id="71-пример-программы">7.1. Пример программы</h3>

<p>Давайте начнём с примерного приложения, которое логирует некоторые сообщения:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.apache.log4j.Logger</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Log4jExample</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Logger</span> <span class="n">logger</span> <span class="o">=</span> <span class="nc">Logger</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="nc">Log4jExample</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">2000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"This is the "</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">" time I say 'Hello World'."</span><span class="o">);</span>
            <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Приложение простое — оно записывает некоторые сообщения в цикле с короткой задержкой между итерациями. В нём 2,000 итераций, и в каждой итерации есть пауза в 100 мс. Таким образом, выполнение должно занять около трёх с половиной минут. Мы будем использовать это приложение в наших примерах ниже.</p>

<h3 id="72-логирование-в-консоль">7.2. Логирование в консоль</h3>

<p>Консоль является местом по умолчанию для логирования сообщений, если конфигурационный файл не найден. Давайте создадим конфигурацию log4j.properties для ConsoleAppender с корневым логгером и также определим уровень логирования для него:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Корневой логгер
log4j.rootLogger=INFO, stdout

# Направляем лог-сообщения в stdout
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target=System.out
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n
</code></pre></div></div>

<p>Здесь мы определили файл log4j.properties со следующими спецификациями:</p>

<ul>
  <li>Мы установили уровень корневого логгера как INFO. Это означает, что все лог-события с уровнем INFO и выше будут записываться. Мы также задали имя для аппендера как stdout.</li>
  <li>Поскольку мы хотим направить логи в консоль, мы назначили аппендер как org.apache.log4j.ConsoleAppender и цель как System.out.</li>
  <li>Наконец, мы указали формат для PatternLayout, в котором хотим выводить логи, используя ConversionPattern.</li>
</ul>

<p>Давайте также разберём значение каждого из символов преобразования в ConversionPattern, которые мы использовали:</p>

<ul>
  <li><strong>%d</strong> добавляет временную метку в заданном формате.</li>
  <li><strong>%-5p</strong> добавляет информацию об уровне логирования к каждому лог-сообщению. Это означает, что приоритет события логирования должен быть выровнен по левому краю с шириной в пять символов.</li>
  <li><strong>%c{1}</strong> выводит квалифицированное имя класса, опционально за которым следуют имена пакетов (квалификатор точности), то есть логирует конкретное лог-сообщение.</li>
  <li><strong>%L</strong> выводит номер строки конкретного лог-события.</li>
  <li><strong>%m</strong> выводит фактическое лог-сообщение.</li>
  <li><strong>%n</strong> добавляет новую строку после каждого лог-сообщения.</li>
</ul>

<p>Таким образом, когда мы запускаем наше примерное приложение, мы получаем следующие строки, напечатанные в консоли:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2023-08-01 00:27:25 INFO Log4jExample:15 - This is the 1 time I say 'Hello World'.
...
...
2023-08-01 00:27:25 INFO Log4jExample:15 - This is the 2000 time I say 'Hello World'.
</code></pre></div></div>

<p><a href="https://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/PatternLayout.html">Документация для класса PatternLayout</a> объясняет больше о символах преобразования, которые мы можем использовать в зависимости от наших нужд.</p>

<h3 id="73-несколько-назначений">7.3. Несколько назначений</h3>

<p>Как уже обсуждалось ранее, мы можем перенаправлять лог-события в несколько назначений:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Корневой логгер
log4j.rootLogger=INFO, file, stdout

# Перенаправление в файл
log4j.appender.file=org.apache.log4j.RollingFileAppender
log4j.appender.file.File=C:\\Baeldung\\app.log
log4j.appender.file.MaxFileSize=5KB
log4j.appender.file.MaxBackupIndex=2
log4j.appender.file.layout=org.apache.log4j.PatternLayout
log4j.appender.file.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n

# Перенаправление в консоль
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target=System.out
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n
</code></pre></div></div>

<p>Здесь мы использовали два аппендера, чтобы перенаправить лог-сообщения как в файл, так и в консоль. Также мы назначили RollingFileAppender для нашего файлового аппендера. Мы используем RollingFileAppender, когда знаем, что лог-файлы могут со временем увеличиваться в размере.</p>

<p>В нашем примере выше мы использовали RollingFileAppender, который прокручивает лог-файлы на основе как размера, так и количества лог-файлов, используя параметры MaxFileSize и MaxBackupIndex. Таким образом, лог-файл будет прокручиваться, когда его размер достигнет 5 КБ, и мы будем хранить максимум два прокрученных лог-файла в качестве резервной копии.</p>

<p>Когда мы запускаем наше приложение, мы получаем следующие файлы, содержащие те же лог-сообщения, что и в предыдущем примере:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>31/01/2024  10:28    138 app.log
31/01/2024  10:28  5.281 app.log.1
31/01/2024  10:28  5.281 app.log.2
</code></pre></div></div>

<h2 id="8-заключение">8. Заключение</h2>

<p>В этой статье мы рассмотрели Log4j и его три компонента — логгеры, аппендеры и макеты. Мы также поняли синтаксис файла log4j.properties и некоторые простые примеры конфигурации файла log4j.properties.</p>

<p><a href="https://www.baeldung.com/java-log4j-properties-guide">оригинал</a></p>]]></content><author><name>Ринат Мамбетов</name></author><category term="java" /><category term="logging" /><category term="Log4j" /><summary type="html"><![CDATA[Log4J — это популярный фреймворк для логирования с открытым исходным кодом, написанный на Java. Log4j широко используется в различных приложениях на Java. Более того, он является потокобезопасным, быстрым и предоставляет иерархию именованных логгеров. Log4j распространяется под лицензией Apache Software License с открытым исходным кодом.]]></summary></entry><entry><title type="html">Тестирование со Spring Boot</title><link href="http://localhost:4000/java/springboot/testing/2024/06/29/springboot-testing.html" rel="alternate" type="text/html" title="Тестирование со Spring Boot" /><published>2024-06-29T18:18:05+03:00</published><updated>2024-06-29T18:18:05+03:00</updated><id>http://localhost:4000/java/springboot/testing/2024/06/29/springboot-testing</id><content type="html" xml:base="http://localhost:4000/java/springboot/testing/2024/06/29/springboot-testing.html"><![CDATA[<p>В этом руководстве мы рассмотрим написание тестов с использованием встроенной поддержки фреймворка Spring Boot. Мы охватим модульные тесты, которые могут выполняться в изоляции, а также интеграционные тесты, которые будут загружать контекст Spring перед выполнением тестов.</p>

<h2 id="1-настройка-проекта">1. Настройка проекта</h2>
<p>Приложение, которое мы будем использовать в этой статье, представляет собой API, предоставляющее некоторые базовые операции с ресурсом “Employee”. Это типичная многослойная архитектура — вызов API обрабатывается от Контроллера к Сервису и далее к слою хранения данных.</p>

<h2 id="2-зависимости-maven">2. Зависимости Maven</h2>
<p>Сначала давайте добавим наши зависимости для тестирования:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>spring-boot-starter-test<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;scope&gt;</span>test<span class="nt">&lt;/scope&gt;</span>
    <span class="nt">&lt;version&gt;</span>3.3.4<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>com.h2database<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>h2<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;scope&gt;</span>test<span class="nt">&lt;/scope&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div>

<p>Зависимость spring-boot-starter-test является основной и содержит большинство элементов, необходимых для наших тестов.</p>

<p>База данных H2 — это наша база данных в памяти. Она устраняет необходимость в настройке и запуске реальной базы данных для тестирования.</p>

<h2 id="3-интеграционное-тестирование-с-springboottest">3. Интеграционное тестирование с @SpringBootTest</h2>

<p>Как следует из названия, интеграционные тесты сосредоточены на интеграции различных слоев приложения. Это также означает, что здесь не используется мокирование.</p>

<p>В идеале мы должны отделять интеграционные тесты от модульных и не запускать их вместе с модульными тестами. Мы можем сделать это, используя другой профиль, чтобы запускать только интеграционные тесты. Причины для этого могут быть следующими: интеграционные тесты требуют много времени и могут нуждаться в реальной базе данных для выполнения.</p>

<p>Однако в этой статье мы не будем на этом сосредотачиваться и вместо этого воспользуемся хранилищем данных H2 в памяти.</p>

<p>Интеграционные тесты требуют запуска контейнера для выполнения тестовых случаев. Поэтому для этого требуется дополнительная настройка — все это легко реализуется в Spring Boot:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RunWith</span><span class="o">(</span><span class="nc">SpringRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="nd">@SpringBootTest</span><span class="o">(</span>
  <span class="n">webEnvironment</span> <span class="o">=</span> <span class="nc">SpringBootTest</span><span class="o">.</span><span class="na">WebEnvironment</span><span class="o">.</span><span class="na">MOCK</span><span class="o">,</span>
  <span class="n">classes</span> <span class="o">=</span> <span class="nc">Application</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="nd">@AutoConfigureMockMvc</span>
<span class="nd">@TestPropertySource</span><span class="o">(</span>
  <span class="n">locations</span> <span class="o">=</span> <span class="s">"classpath:application-integrationtest.properties"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmployeeRestControllerIntegrationTest</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">MockMvc</span> <span class="n">mvc</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">EmployeeRepository</span> <span class="n">repository</span><span class="o">;</span>

    <span class="c1">// write test cases here</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Аннотация @SpringBootTest полезна, когда нам нужно загрузить весь контейнер. Эта аннотация работает, создавая ApplicationContext, который будет использоваться в наших тестах.</p>

<p>Мы можем использовать атрибут webEnvironment аннотации @SpringBootTest для настройки нашей рабочей среды; здесь мы используем WebEnvironment.MOCK, чтобы контейнер работал в имитированной среде сервлетов.</p>

<p>Далее, аннотация @TestPropertySource помогает настроить расположение файлов свойств, специфичных для наших тестов. Обратите внимание, что файл свойств, загруженный с помощью @TestPropertySource, будет переопределять существующий файл application.properties.</p>

<p>Файл application-integrationtest.properties содержит детали для настройки хранилища данных:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>spring.datasource.url = jdbc:h2:mem:test
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.H2Dialect
</code></pre></div></div>
<p>Если мы хотим запускать наши интеграционные тесты с использованием MySQL, мы можем изменить указанные выше значения в файле свойств.</p>

<p>Тестовые случаи для интеграционных тестов могут выглядеть аналогично модульным тестам слоя Контроллера:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">givenEmployees_whenGetEmployees_thenStatus200</span><span class="o">()</span>
  <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>

    <span class="n">createTestEmployee</span><span class="o">(</span><span class="s">"bob"</span><span class="o">);</span>

    <span class="n">mvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span><span class="n">get</span><span class="o">(</span><span class="s">"/api/employees"</span><span class="o">)</span>
      <span class="o">.</span><span class="na">contentType</span><span class="o">(</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">))</span>
      <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">status</span><span class="o">().</span><span class="na">isOk</span><span class="o">())</span>
      <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">content</span><span class="o">()</span>
      <span class="o">.</span><span class="na">contentTypeCompatibleWith</span><span class="o">(</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">))</span>
      <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">jsonPath</span><span class="o">(</span><span class="s">"$[0].name"</span><span class="o">,</span> <span class="n">is</span><span class="o">(</span><span class="s">"bob"</span><span class="o">)));</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Разница с модульными тестами слоя Контроллера заключается в том, что здесь ничего не мокируется, и будут выполняться сценарии от начала до конца.</p>

<h2 id="4-конфигурация-тестов-с-помощью-testconfiguration">4. Конфигурация тестов с помощью @TestConfiguration</h2>

<p>Как мы видели в предыдущем разделе, тест, аннотированный @SpringBootTest, загрузит полный контекст приложения, что означает, что мы можем использовать @Autowire для любого бина, который будет обнаружен с помощью сканирования компонентов в нашем тесте:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RunWith</span><span class="o">(</span><span class="nc">SpringRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="nd">@SpringBootTest</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmployeeServiceImplIntegrationTest</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">EmployeeService</span> <span class="n">employeeService</span><span class="o">;</span>

    <span class="c1">// class code ...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Однако мы можем захотеть избежать загрузки реального контекста приложения и использовать специальную конфигурацию для тестов. Мы можем достичь этого с помощью аннотации @TestConfiguration. Существует два способа использования этой аннотации. Либо на статическом внутреннем классе в том же тестовом классе, где мы хотим использовать @Autowire для бина:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RunWith</span><span class="o">(</span><span class="nc">SpringRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmployeeServiceImplIntegrationTest</span> <span class="o">{</span>

    <span class="nd">@TestConfiguration</span>
    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">EmployeeServiceImplTestContextConfiguration</span> <span class="o">{</span>
        <span class="nd">@Bean</span>
        <span class="kd">public</span> <span class="nc">EmployeeService</span> <span class="nf">employeeService</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">EmployeeService</span><span class="o">()</span> <span class="o">{</span>
                <span class="c1">// implement methods</span>
            <span class="o">};</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">EmployeeService</span> <span class="n">employeeService</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>В качестве альтернативы мы можем создать отдельный класс конфигурации для тестов:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@TestConfiguration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmployeeServiceImplTestContextConfiguration</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">EmployeeService</span> <span class="nf">employeeService</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">EmployeeService</span><span class="o">()</span> <span class="o">{</span>
            <span class="c1">// implement methods</span>
        <span class="o">};</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Классы конфигурации, аннотированные @TestConfiguration, исключаются из сканирования компонентов, поэтому нам нужно явно импортировать их в каждом тесте, где мы хотим использовать @Autowire. Мы можем сделать это с помощью аннотации @Import:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RunWith</span><span class="o">(</span><span class="nc">SpringRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="nd">@Import</span><span class="o">(</span><span class="nc">EmployeeServiceImplTestContextConfiguration</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmployeeServiceImplIntegrationTest</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">EmployeeService</span> <span class="n">employeeService</span><span class="o">;</span>

    <span class="c1">// remaining class code</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="5-мокирование-с-помощью-mockbean">5. Мокирование с помощью @MockBean</h2>

<p>Наш код слоя Сервиса зависит от нашего Репозитория:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmployeeServiceImpl</span> <span class="kd">implements</span> <span class="nc">EmployeeService</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">EmployeeRepository</span> <span class="n">employeeRepository</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Employee</span> <span class="nf">getEmployeeByName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">employeeRepository</span><span class="o">.</span><span class="na">findByName</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Однако, чтобы протестировать слой Сервиса, нам не нужно знать или беспокоиться о том, как реализован слой Хранения данных. В идеале мы должны иметь возможность писать и тестировать наш код слоя Сервиса без подключения полного слоя Хранения данных.</p>

<p>Для достижения этой цели мы можем использовать поддержку мокирования, предоставляемую Spring Boot Test.</p>

<p>Давайте сначала взглянем на скелет тестового класса:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RunWith</span><span class="o">(</span><span class="nc">SpringRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmployeeServiceImplIntegrationTest</span> <span class="o">{</span>

    <span class="nd">@TestConfiguration</span>
    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">EmployeeServiceImplTestContextConfiguration</span> <span class="o">{</span>

        <span class="nd">@Bean</span>
        <span class="kd">public</span> <span class="nc">EmployeeService</span> <span class="nf">employeeService</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">EmployeeServiceImpl</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">EmployeeService</span> <span class="n">employeeService</span><span class="o">;</span>

    <span class="nd">@MockBean</span>
    <span class="kd">private</span> <span class="nc">EmployeeRepository</span> <span class="n">employeeRepository</span><span class="o">;</span>

    <span class="c1">// write test cases here</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Чтобы проверить класс Сервиса, нам нужно создать экземпляр класса Сервиса и сделать его доступным как @Bean, чтобы мы могли использовать @Autowire в нашем тестовом классе. Мы можем достичь этой конфигурации с помощью аннотации @TestConfiguration.</p>

<p>Еще один интересный момент здесь — это использование @MockBean. Она создает мок для EmployeeRepository, который можно использовать для обхода вызова к реальному EmployeeRepository:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Before</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setUp</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">Employee</span> <span class="n">alex</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Employee</span><span class="o">(</span><span class="s">"alex"</span><span class="o">);</span>

    <span class="nc">Mockito</span><span class="o">.</span><span class="na">when</span><span class="o">(</span><span class="n">employeeRepository</span><span class="o">.</span><span class="na">findByName</span><span class="o">(</span><span class="n">alex</span><span class="o">.</span><span class="na">getName</span><span class="o">()))</span>
      <span class="o">.</span><span class="na">thenReturn</span><span class="o">(</span><span class="n">alex</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Поскольку настройка завершена, тестовый случай будет проще:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">whenValidName_thenEmployeeShouldBeFound</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"alex"</span><span class="o">;</span>
    <span class="nc">Employee</span> <span class="n">found</span> <span class="o">=</span> <span class="n">employeeService</span><span class="o">.</span><span class="na">getEmployeeByName</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>

     <span class="n">assertThat</span><span class="o">(</span><span class="n">found</span><span class="o">.</span><span class="na">getName</span><span class="o">())</span>
      <span class="o">.</span><span class="na">isEqualTo</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
 <span class="o">}</span>
</code></pre></div></div>

<h2 id="6-интеграционное-тестирование-с-помощью-datajpatest">6. Интеграционное тестирование с помощью @DataJpaTest</h2>

<p>Мы будем работать с сущностью под названием Employee (Сотрудник), которая имеет свойства id (идентификатор) и name (имя).</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"person"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Employee</span> <span class="o">{</span>

    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">GenerationType</span><span class="o">.</span><span class="na">AUTO</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@Size</span><span class="o">(</span><span class="n">min</span> <span class="o">=</span> <span class="mi">3</span><span class="o">,</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">20</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="c1">// standard getters and setters, constructors</span>
<span class="o">}</span>
</code></pre></div></div>

<p>А вот и наш репозиторий, использующий Spring Data JPA:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Repository</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">EmployeeRepository</span> <span class="kd">extends</span> <span class="nc">JpaRepository</span><span class="o">&lt;</span><span class="nc">Employee</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nc">Employee</span> <span class="nf">findByName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">);</span>

<span class="o">}</span>
</code></pre></div></div>

<p>На этом код для слоя Хранения данных завершен. Теперь давайте перейдем к написанию нашего тестового класса.</p>

<p>Сначала создадим каркас нашего тестового класса:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RunWith</span><span class="o">(</span><span class="nc">SpringRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="nd">@DataJpaTest</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmployeeRepositoryIntegrationTest</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">TestEntityManager</span> <span class="n">entityManager</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">EmployeeRepository</span> <span class="n">employeeRepository</span><span class="o">;</span>

    <span class="c1">// write test cases here</span>

<span class="o">}</span>
</code></pre></div></div>

<p>@RunWith(SpringRunner.class) обеспечивает связь между возможностями тестирования Spring Boot и JUnit. Каждый раз, когда мы используем какие-либо функции тестирования Spring Boot в наших тестах JUnit, эта аннотация будет необходима.</p>

<p>@DataJpaTest предоставляет стандартную настройку, необходимую для тестирования слоя Хранения данных:</p>

<ul>
  <li>конфигурация H2, базы данных в памяти</li>
  <li>настройка Hibernate, Spring Data и DataSource</li>
  <li>выполнение @EntityScan</li>
  <li>включение логирования SQL</li>
</ul>

<p>Чтобы выполнить операции с базой данных, нам нужны некоторые записи, уже находящиеся в нашей базе данных. Для настройки этих данных мы можем использовать TestEntityManager.</p>

<p>TestEntityManager в Spring Boot является альтернативой стандартному JPA EntityManager и предоставляет методы, которые обычно используются при написании тестов.</p>

<p>EmployeeRepository — это компонент, который мы собираемся тестировать.</p>

<p>Теперь давайте напишем наш первый тестовый случай:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">whenFindByName_thenReturnEmployee</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// given</span>
    <span class="nc">Employee</span> <span class="n">alex</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Employee</span><span class="o">(</span><span class="s">"alex"</span><span class="o">);</span>
    <span class="n">entityManager</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">alex</span><span class="o">);</span>
    <span class="n">entityManager</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>

    <span class="c1">// when</span>
    <span class="nc">Employee</span> <span class="n">found</span> <span class="o">=</span> <span class="n">employeeRepository</span><span class="o">.</span><span class="na">findByName</span><span class="o">(</span><span class="n">alex</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>

    <span class="c1">// then</span>
    <span class="n">assertThat</span><span class="o">(</span><span class="n">found</span><span class="o">.</span><span class="na">getName</span><span class="o">())</span>
      <span class="o">.</span><span class="na">isEqualTo</span><span class="o">(</span><span class="n">alex</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>

<p>В приведенном выше тесте мы используем TestEntityManager для вставки записи Employee в базу данных и считываем ее с помощью API поиска по имени.</p>

<p>Часть assertThat(…) принадлежит библиотеке Assertj, которая поставляется в комплекте со Spring Boot.</p>

<h2 id="7-модульное-тестирование-с-помощью-webmvctest">7. Модульное тестирование с помощью @WebMvcTest</h2>

<p>Наш контроллер зависит от слоя Сервиса; давайте включим только один метод для простоты:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RestController</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/api"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmployeeRestController</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">EmployeeService</span> <span class="n">employeeService</span><span class="o">;</span>

    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"/employees"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Employee</span><span class="o">&gt;</span> <span class="nf">getAllEmployees</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">employeeService</span><span class="o">.</span><span class="na">getAllEmployees</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Поскольку мы сосредоточены только на коде контроллера, естественно, что мы будем использовать мокирование кода слоя Сервиса для наших модульных тестов:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RunWith</span><span class="o">(</span><span class="nc">SpringRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="nd">@WebMvcTest</span><span class="o">(</span><span class="nc">EmployeeRestController</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmployeeRestControllerIntegrationTest</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">MockMvc</span> <span class="n">mvc</span><span class="o">;</span>

    <span class="nd">@MockBean</span>
    <span class="kd">private</span> <span class="nc">EmployeeService</span> <span class="n">service</span><span class="o">;</span>

    <span class="c1">// write test cases here</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Для тестирования контроллеров мы можем использовать @WebMvcTest. Он автоматически настраивает инфраструктуру Spring MVC для наших модульных тестов.</p>

<p>В большинстве случаев @WebMvcTest будет ограничен инициализацией одного контроллера. Мы также можем использовать его вместе с @MockBean, чтобы предоставить мокированные реализации для любых необходимых зависимостей.</p>

<p>@WebMvcTest также автоматически настраивает MockMvc, который предлагает мощный способ простого тестирования MVC контроллеров без запуска полного HTTP-сервера.</p>

<p>Сказав это, давайте напишем наш тестовый случай:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">givenEmployees_whenGetEmployees_thenReturnJsonArray</span><span class="o">()</span>
  <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>

    <span class="nc">Employee</span> <span class="n">alex</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Employee</span><span class="o">(</span><span class="s">"alex"</span><span class="o">);</span>

    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Employee</span><span class="o">&gt;</span> <span class="n">allEmployees</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">alex</span><span class="o">);</span>

    <span class="n">given</span><span class="o">(</span><span class="n">service</span><span class="o">.</span><span class="na">getAllEmployees</span><span class="o">()).</span><span class="na">willReturn</span><span class="o">(</span><span class="n">allEmployees</span><span class="o">);</span>

    <span class="n">mvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span><span class="n">get</span><span class="o">(</span><span class="s">"/api/employees"</span><span class="o">)</span>
      <span class="o">.</span><span class="na">contentType</span><span class="o">(</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">))</span>
      <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">status</span><span class="o">().</span><span class="na">isOk</span><span class="o">())</span>
      <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">jsonPath</span><span class="o">(</span><span class="s">"$"</span><span class="o">,</span> <span class="n">hasSize</span><span class="o">(</span><span class="mi">1</span><span class="o">)))</span>
      <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">jsonPath</span><span class="o">(</span><span class="s">"$[0].name"</span><span class="o">,</span> <span class="n">is</span><span class="o">(</span><span class="n">alex</span><span class="o">.</span><span class="na">getName</span><span class="o">())));</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Вызов метода get(…) можно заменить другими методами, соответствующими HTTP-методам, таким как put(), post() и т. д. Обратите внимание, что мы также устанавливаем тип содержимого в запросе.</p>

<p>MockMvc является гибким, и мы можем создавать любые запросы с его помощью.</p>

<h2 id="8-автоматически-настраиваемые-тесты">8. Автоматически настраиваемые тесты</h2>

<p>Одной из удивительных особенностей автоматической настройки аннотаций Spring Boot является то, что они помогают загружать части полного приложения и тестировать специфические слои кодовой базы.</p>

<p>В дополнение к вышеупомянутым аннотациям, вот список нескольких широко используемых аннотаций:</p>

<ul>
  <li><strong>@WebFluxTest</strong>: Мы можем использовать аннотацию @WebFluxTest для тестирования контроллеров Spring WebFlux. Она часто используется вместе с @MockBean для предоставления мокированных реализаций необходимых зависимостей.</li>
  <li><strong>@JdbcTest</strong>: Мы можем использовать аннотацию @JdbcTest для тестирования JPA приложений, но она предназначена для тестов, которые требуют только DataSource. Аннотация настраивает встроенную базу данных в памяти и JdbcTemplate.</li>
  <li><strong>@JooqTest</strong>: Для тестирования, связанного с jOOQ, мы можем использовать аннотацию @JooqTest, которая настраивает DSLContext.</li>
  <li><strong>@DataMongoTest</strong>: Для тестирования приложений MongoDB полезна аннотация @DataMongoTest. По умолчанию она настраивает встроенную базу данных MongoDB в памяти, если драйвер доступен через зависимости, настраивает MongoTemplate, сканирует классы с аннотацией @Document и настраивает репозитории Spring Data MongoDB.</li>
  <li><strong>@DataRedisTest</strong>: Упрощает тестирование приложений Redis. Она сканирует классы с аннотацией @RedisHash и по умолчанию настраивает репозитории Spring Data Redis.</li>
  <li><strong>@DataLdapTest</strong>: Настраивает встроенный LDAP в памяти (если доступен), настраивает LdapTemplate, сканирует классы с аннотацией @Entry и по умолчанию настраивает репозитории Spring Data LDAP.</li>
  <li><strong>@RestClientTest</strong>: Обычно мы используем аннотацию @RestClientTest для тестирования REST-клиентов. Она автоматически настраивает различные зависимости, такие как поддержка Jackson, GSON и Jsonb; настраивает RestTemplateBuilder и по умолчанию добавляет поддержку MockRestServiceServer.</li>
  <li><strong>@JsonTest</strong>: Инициализирует контекст приложения Spring только с теми бинами, которые необходимы для тестирования сериализации JSON.</li>
</ul>

<p><a href="https://www.baeldung.com/spring-boot-testing">оригинал</a></p>]]></content><author><name>Ринат Мамбетов</name></author><category term="java" /><category term="springboot" /><category term="testing" /><summary type="html"><![CDATA[В этом руководстве мы рассмотрим написание тестов с использованием встроенной поддержки фреймворка Spring Boot. Мы охватим модульные тесты, которые могут выполняться в изоляции, а также интеграционные тесты, которые будут загружать контекст Spring перед выполнением тестов.]]></summary></entry><entry><title type="html">Руководство по Java 8 Stream API</title><link href="http://localhost:4000/java/stream/2024/06/21/java-stream.html" rel="alternate" type="text/html" title="Руководство по Java 8 Stream API" /><published>2024-06-21T18:18:05+03:00</published><updated>2024-06-21T18:18:05+03:00</updated><id>http://localhost:4000/java/stream/2024/06/21/java-stream</id><content type="html" xml:base="http://localhost:4000/java/stream/2024/06/21/java-stream.html"><![CDATA[<p>В этом руководстве рассматривается практическое использование Java 8 Streams от создания до параллельного выполнения.</p>

<p>Чтобы понять этот материал, читателям необходимо иметь базовые знания о Java 8 (лямбда-выражения, Optional, ссылки на методы).</p>

<h2 id="1-создание-потока">1. Создание потока</h2>

<p>В Java существует множество способов создания экземпляра потока из различных источников данных.</p>

<p>После создания экземпляра потока, он не изменяет исходный источник данных. Это означает, что любые операции, выполняемые над потоком (например, фильтрация, маппинг, сортировка), не влияют на сам исходный набор данных. Это обеспечивает безопасность данных и предотвращает нежелательные побочные эффекты.</p>

<p>Благодаря тому, что потоки не модифицируют исходные данные, из одного и того же источника можно создать несколько потоков. Это позволяет одновременно выполнять различные операции обработки данных над одним и тем же набором данных без изменения исходных данных.</p>

<h3 id="11-пустой-поток">1.1. Пустой поток</h3>

<p>Мы должны использовать метод <code class="language-plaintext highlighter-rouge">empty()</code> для создания пустого потока:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">streamEmpty</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">empty</span><span class="o">();</span>
</code></pre></div></div>

<p>Мы часто используем метод <code class="language-plaintext highlighter-rouge">empty()</code> при создании, чтобы избежать возврата null для потоков без элементов:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">streamOf</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">list</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">list</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">?</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">empty</span><span class="o">()</span> <span class="o">:</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="12-поток-коллекции">1.2. Поток коллекции</h3>

<p>Мы также можем создать поток из любого типа коллекции:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Collection</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">collection</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">);</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">streamOfCollection</span> <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="na">stream</span><span class="o">();</span>
</code></pre></div></div>

<h3 id="13-поток-массива">1.3. Поток массива</h3>

<p>Массив также может быть источником потока:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">streamOfArray</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">);</span>
</code></pre></div></div>

<p>Мы также можем создать Stream из существующего массива или части массива:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[]{</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">};</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">streamOfArrayFull</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">arr</span><span class="o">);</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">streamOfArrayPart</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span> <span class="c1">// "b" "c"</span>
</code></pre></div></div>

<h3 id="14-streambuilder">1.4. Stream.builder()</h3>

<p>Желаемый тип должен быть дополнительно указан в правой части инструкции, когда используется Builder, в противном случае метод <code class="language-plaintext highlighter-rouge">build()</code> создаст экземпляр <code class="language-plaintext highlighter-rouge">Stream&lt;Object&gt;</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">streamBuilder</span> <span class="o">=</span>
  <span class="nc">Stream</span><span class="o">.&lt;</span><span class="nc">String</span><span class="o">&gt;</span><span class="n">builder</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="s">"a"</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="s">"b"</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="s">"c"</span><span class="o">).</span><span class="na">build</span><span class="o">();</span>
</code></pre></div></div>

<h3 id="15-streamgenerate">1.5. Stream.generate()</h3>

<p>Метод <code class="language-plaintext highlighter-rouge">generate()</code> принимает <code class="language-plaintext highlighter-rouge">Supplier&lt;T&gt;</code> для генерации элемента. Поскольку результирующий поток бесконечен, разработчик должен указать желаемый размер, иначе метод generate() будет работать до тех пор, пока не достигнет предела памяти:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">streamGenerated</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">generate</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="s">"element"</span><span class="o">).</span><span class="na">limit</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
</code></pre></div></div>

<p>Приведенный выше код создает последовательность из десяти строк со значением “element”.</p>

<h3 id="16-streamiterate">1.6. Stream.iterate()</h3>

<p>Другой способ создания бесконечного потока - это использование метода <code class="language-plaintext highlighter-rouge">iterate()</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">streamIterated</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">iterate</span><span class="o">(</span><span class="mi">40</span><span class="o">,</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="o">).</span><span class="na">limit</span><span class="o">(</span><span class="mi">20</span><span class="o">);</span>
</code></pre></div></div>

<p>Первый элемент результирующего stream является первым параметром метода <code class="language-plaintext highlighter-rouge">iterate()</code>. При создании каждого следующего элемента указанная функция применяется к предыдущему элементу. В приведенном выше примере вторым элементом будет 42.</p>

<h3 id="17-поток-примитивов">1.7. Поток примитивов</h3>

<p>Java 8 предлагает возможность создавать потоки из трех примитивных типов: int, long и double. Поскольку <code class="language-plaintext highlighter-rouge">Stream&lt;T&gt;</code> является универсальным интерфейсом, и нет способа использовать примитивы в качестве параметра типа с generics, были созданы три новых специальных интерфейса: IntStream, LongStream, DoubleStream.</p>

<p>Использование новых интерфейсов устраняет ненужную автоматическую упауовку, что позволяет повысить производительность:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IntStream</span> <span class="n">intStream</span> <span class="o">=</span> <span class="nc">IntStream</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
<span class="nc">LongStream</span> <span class="n">longStream</span> <span class="o">=</span> <span class="nc">LongStream</span><span class="o">.</span><span class="na">rangeClosed</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
</code></pre></div></div>

<p>Метод <code class="language-plaintext highlighter-rouge">range(int startInclusive, int endExclusive)</code> создает упорядоченный поток от первого параметра ко второму параметру. Оно увеличивает значение последующих элементов с шагом, равным 1. Результат не включает последний параметр, это просто верхняя граница последовательности.</p>

<p>Метод <code class="language-plaintext highlighter-rouge">rangeClosed(int startInclusive, int endInclusive)</code>  выполняет то же самое, только с одним отличием, включен второй элемент. Мы можем использовать эти два метода для генерации любого из трех типов потоков примитивов.</p>

<p>Начиная с Java 8, класс Random предоставляет широкий спектр методов для генерации потоков примитивов. Например, следующий код создает DoubleStream, который состоит из трех элементов:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Random</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>
<span class="nc">DoubleStream</span> <span class="n">doubleStream</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="na">doubles</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="18-поток-строк">1.8. Поток строк</h3>

<p>Мы также можем использовать String в качестве источника для создания потока с помощью метода <code class="language-plaintext highlighter-rouge">chars()</code> класса String. Поскольку в JDK нет интерфейса для CharStream, мы используем IntStream вместо этого для представления потока символов.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IntStream</span> <span class="n">streamOfChars</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">.</span><span class="na">chars</span><span class="o">();</span>
</code></pre></div></div>

<p>Следующий пример разбивает строку на подстроки в соответствии с указанным регулярным выражением:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">streamOfString</span> <span class="o">=</span>
  <span class="nc">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">", "</span><span class="o">).</span><span class="na">splitAsStream</span><span class="o">(</span><span class="s">"a, b, c"</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="19-поток-файлов">1.9. Поток файлов</h3>

<p>Кроме того, Java NIO класс Files позволяет нам генерировать <code class="language-plaintext highlighter-rouge">Stream&lt;String&gt;</code> текстового файла с помощью метода <code class="language-plaintext highlighter-rouge">lines()</code>. Каждая строка текста становится элементом потока:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Path</span> <span class="n">path</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"C:\\file.txt"</span><span class="o">);</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">streamOfStrings</span> <span class="o">=</span> <span class="nc">Files</span><span class="o">.</span><span class="na">lines</span><span class="o">(</span><span class="n">path</span><span class="o">);</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">streamWithCharset</span> <span class="o">=</span>
  <span class="nc">Files</span><span class="o">.</span><span class="na">lines</span><span class="o">(</span><span class="n">path</span><span class="o">,</span> <span class="nc">Charset</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"UTF-8"</span><span class="o">));</span>
</code></pre></div></div>

<p>Кодировка может быть указана в качестве аргумента метода <code class="language-plaintext highlighter-rouge">lines()</code>.</p>

<h2 id="2-ссылка-на-поток">2. Ссылка на поток</h2>

<p>Мы можем создать экземпляр потока и иметь доступную ссылку на него, если вызываются только промежуточные операции. Выполнение терминальной операции делает поток недоступным.</p>

<p>Чтобы продемонстрировать это, мы ненадолго забудем, что наилучшей практикой является объединение последовательности операций в цепочку. Помимо ненужной многословности, технически следующий код допустим:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stream</span> <span class="o">=</span>
  <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">).</span><span class="na">filter</span><span class="o">(</span><span class="n">element</span> <span class="o">-&gt;</span> <span class="n">element</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">"b"</span><span class="o">));</span>
<span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">anyElement</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="na">findAny</span><span class="o">();</span>
</code></pre></div></div>

<p>Однако попытка повторно использовать ту же ссылку после вызова операции терминала вызовет исключение IllegalStateException:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">firstElement</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="na">findFirst</span><span class="o">();</span>
</code></pre></div></div>

<p>Поскольку исключение IllegalStateException является исключением RuntimeException, компилятор не будет сигнализировать о проблеме. Поэтому очень важно помнить, что потоки Java 8 нельзя использовать повторно.</p>

<p>Такое поведение логично. Мы создали Stream для применения конечной последовательности операций к источнику элементов в функциональном стиле, а не для хранения элементов.</p>

<p>Итак, чтобы предыдущий код работал должным образом, необходимо внести некоторые изменения:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">elements</span> <span class="o">=</span>
  <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">).</span><span class="na">filter</span><span class="o">(</span><span class="n">element</span> <span class="o">-&gt;</span> <span class="n">element</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">"b"</span><span class="o">))</span>
    <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
<span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">anyElement</span> <span class="o">=</span> <span class="n">elements</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">findAny</span><span class="o">();</span>
<span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">firstElement</span> <span class="o">=</span> <span class="n">elements</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">findFirst</span><span class="o">();</span>
</code></pre></div></div>

<h2 id="3-потоковый-конвейер">3. Потоковый конвейер</h2>

<p>Для выполнения последовательности операций над элементами источника данных и агрегирования их результатов нам понадобятся три части: исходный код, промежуточные операции и терминальная операция.</p>

<p>Промежуточные операции возвращают новый измененный поток. Например, чтобы создать новый поток вместо существующего без нескольких элементов, следует использовать метод <code class="language-plaintext highlighter-rouge">skip()</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">onceModifiedStream</span> <span class="o">=</span>
  <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"abcd"</span><span class="o">,</span> <span class="s">"bbcd"</span><span class="o">,</span> <span class="s">"cbcd"</span><span class="o">).</span><span class="na">skip</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
</code></pre></div></div>

<p>Если нам нужно больше одной модификации, мы можем связать промежуточные операции. Давайте предположим, что нам также нужно заменить каждый элемент текущего <code class="language-plaintext highlighter-rouge">Stream&lt;String&gt;</code> подстрокой из первых нескольких символов. Мы можем сделать это, объединив методы <code class="language-plaintext highlighter-rouge">skip()</code> и <code class="language-plaintext highlighter-rouge">map()</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">twiceModifiedStream</span> <span class="o">=</span>
  <span class="n">stream</span><span class="o">.</span><span class="na">skip</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">map</span><span class="o">(</span><span class="n">element</span> <span class="o">-&gt;</span> <span class="n">element</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">));</span>
</code></pre></div></div>

<p>Поток сам по себе ничего не стоит; пользователя интересует результат операции терминала, который может быть значением некоторого типа или действием, применяемым к каждому элементу потока. Мы можем использовать только одну терминальную операцию для каждого потока.</p>

<p>Правильный и наиболее удобный способ использования потоков - это конвейер потока, который представляет собой цепочку из источника потока, промежуточных операций и терминальной операции:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"abc1"</span><span class="o">,</span> <span class="s">"abc2"</span><span class="o">,</span> <span class="s">"abc3"</span><span class="o">);</span>
<span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">skip</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
  <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">element</span> <span class="o">-&gt;</span> <span class="n">element</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">)).</span><span class="na">sorted</span><span class="o">().</span><span class="na">count</span><span class="o">();</span>
</code></pre></div></div>

<h2 id="4-отложенный-вызов">4. Отложенный вызов</h2>

<p>Промежуточные операции являются ленивыми. Это означает, что они будут вызываться только в том случае, если это необходимо для выполнения терминальной операции.</p>

<p>Например, давайте вызовем метод <code class="language-plaintext highlighter-rouge">wasCalled()</code>, который увеличивает внутренний счетчик при каждом вызове:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">long</span> <span class="n">counter</span><span class="o">;</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">wasCalled</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">counter</span><span class="o">++;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Теперь давайте вызовем метод <code class="language-plaintext highlighter-rouge">wasCalled()</code> из операции <code class="language-plaintext highlighter-rouge">filter()</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"abc1"</span><span class="o">,</span> <span class="s">"abc2"</span><span class="o">,</span> <span class="s">"abc3"</span><span class="o">);</span>
<span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">filter</span><span class="o">(</span><span class="n">element</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="n">wasCalled</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">element</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">"2"</span><span class="o">);</span>
<span class="o">});</span>
</code></pre></div></div>

<p>Поскольку у нас есть источник из трех элементов, мы можем предположить, что метод <code class="language-plaintext highlighter-rouge">filter()</code> будет вызван три раза, а значение переменной counter будет равно 3. Однако выполнение этого кода вообще не изменяет счетчик , он по-прежнему равен нулю, поэтому метод <code class="language-plaintext highlighter-rouge">filter()</code> даже не был вызван ни разу. Причина, это отсутствие терминальной операции.</p>

<p>Давайте немного перепишем этот код, добавив операцию <code class="language-plaintext highlighter-rouge">map()</code> и терминальную операцию, <code class="language-plaintext highlighter-rouge">findFirst()</code>. Мы также добавим возможность отслеживать порядок вызовов методов с помощью ведения журнала:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">filter</span><span class="o">(</span><span class="n">element</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"filter() was called"</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">element</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">"2"</span><span class="o">);</span>
<span class="o">}).</span><span class="na">map</span><span class="o">(</span><span class="n">element</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"map() was called"</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">element</span><span class="o">.</span><span class="na">toUpperCase</span><span class="o">();</span>
<span class="o">}).</span><span class="na">findFirst</span><span class="o">();</span>
</code></pre></div></div>

<p>Результирующий журнал показывает, что мы дважды вызывали метод <code class="language-plaintext highlighter-rouge">filter()</code> и один раз метод <code class="language-plaintext highlighter-rouge">map()</code>. Это потому, что конвейер выполняется вертикально. В нашем примере первый элемент stream не удовлетворял предикату filter. Затем мы вызвали метод <code class="language-plaintext highlighter-rouge">filter()</code> для второго элемента, который прошел фильтр. Не вызывая <code class="language-plaintext highlighter-rouge">filter()</code> для третьего элемента, мы перешли по конвейеру к методу <code class="language-plaintext highlighter-rouge">map()</code>.</p>

<p>Операция <code class="language-plaintext highlighter-rouge">findFirst()</code> удовлетворяет только одному элементу. Итак, в этом конкретном примере отложенный вызов позволил нам избежать двух вызовов метода, одного для <code class="language-plaintext highlighter-rouge">filter()</code> (для третьего элемента) и одного для <code class="language-plaintext highlighter-rouge">map()</code> (для первого элемента).</p>

<h2 id="5-порядок-выполнения">5. Порядок выполнения</h2>

<p>С точки зрения производительности, правильный порядок является одним из наиболее важных аспектов операций объединения в цепочку в конвейере stream:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">map</span><span class="o">(</span><span class="n">element</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="n">wasCalled</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">element</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
<span class="o">}).</span><span class="na">skip</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="na">count</span><span class="o">();</span>
</code></pre></div></div>

<p>Выполнение этого кода увеличит значение счетчика на три. Это означает, что мы вызвали метод stream три раза, но значение size равно единице. Итак, результирующий поток содержит только один элемент, и мы выполнили дорогостоящие операции map() без причины два раза из трех.</p>

<p>Если мы изменим порядок методов skip() и map(), то счетчик увеличится всего на единицу. Итак, мы вызовем метод <code class="language-plaintext highlighter-rouge">map()</code> только один раз:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">skip</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="na">map</span><span class="o">(</span><span class="n">element</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="n">wasCalled</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">element</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
<span class="o">}).</span><span class="na">count</span><span class="o">();</span>
</code></pre></div></div>

<p>Это подводит нас к следующему правилу: промежуточные операции, которые уменьшают размер потока, должны быть размещены перед операциями, которые применяются к каждому элементу. Итак, нам нужно сохранить такие методы, как <code class="language-plaintext highlighter-rouge">skip()</code>, <code class="language-plaintext highlighter-rouge">filter()</code>, и <code class="language-plaintext highlighter-rouge">distinct()</code> в верхней части нашего конвейера stream.</p>

<h2 id="6-сокращение-потока">6. Сокращение потока</h2>

<p>API имеет множество терминальных операций, которые сводят поток к типу или примитиву: <code class="language-plaintext highlighter-rouge">count()</code>, <code class="language-plaintext highlighter-rouge">max()</code>, <code class="language-plaintext highlighter-rouge">min()</code>, и <code class="language-plaintext highlighter-rouge">sum()</code>. Однако эти операции работают в соответствии с предопределенной реализацией. Ну и что, если разработчику необходимо настроить механизм сокращения потока? Есть два метода, которые позволяют нам сделать это, методы <code class="language-plaintext highlighter-rouge">reduce()</code> и <code class="language-plaintext highlighter-rouge">collect()</code>.</p>

<h3 id="61-метод-reduce-объединение">6.1. Метод reduce() (объединение)</h3>

<p>Существует три варианта этого метода, которые отличаются своими сигнатурами и типами возвращаемых данных. Они могут иметь следующие параметры:</p>

<p>identity – начальное значение для накопителя или значение по умолчанию, если поток пуст и накапливать нечего</p>

<p>accumulator – функция, которая определяет логику агрегирования элементов. Поскольку accumulator создает новое значение для каждого шага объединения, количество новых значений равно размеру потока, и полезно только последнее значение. Это не очень хорошо сказывается на производительности.</p>

<p>combiner – функция, которая агрегирует результаты сумматора. Мы вызываем combiner только в параллельном режиме, чтобы объединить результаты accumulators из разных потоков.</p>

<p>Теперь давайте посмотрим на эти три метода в действии:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">OptionalInt</span> <span class="n">reduced</span> <span class="o">=</span>
  <span class="nc">IntStream</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">).</span><span class="na">reduce</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">);</span> <span class="c1">// 6 (1 + 2 + 3)</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">reducedTwoParams</span> <span class="o">=</span>
  <span class="nc">IntStream</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">).</span><span class="na">reduce</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">);</span> <span class="c1">// 16 (10 + 1 + 2 + 3)</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">reducedParams</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
  <span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
     <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"combiner was called"</span><span class="o">);</span>
     <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span>
  <span class="o">});</span>
</code></pre></div></div>

<p>Результат будет таким же, как в предыдущем примере (16), и логирования не будет, что означает, что combiner не вызывался. Чтобы combiner работал, поток должен быть параллельным:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">reducedParallel</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="na">parallelStream</span><span class="o">()</span>
    <span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
       <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"combiner was called"</span><span class="o">);</span>
       <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span>
    <span class="o">});</span>
</code></pre></div></div>

<p>Результат здесь другой (36), и combiner вызывался дважды. Здесь объединение выполняется по следующему алгоритму: накопитель запускается три раза путем добавления каждого элемента потока к identity. Эти действия выполняются параллельно. В результате у них получилось (10 + 1 = 11; 10 + 2 = 12; 10 + 3 = 13;). Теперь combiner может объединить эти три результата. Для этого требуется две итерации (12 + 13 = 25; 25 + 11 = 36).</p>

<h3 id="62-метод-collect">6.2. Метод collect()</h3>

<p>Объединение потока также может быть выполнено с помощью другой терминальной операции, метода <code class="language-plaintext highlighter-rouge">collect()</code>. Он принимает аргумент типа Collector, который определяет механизм объединения. Для большинства распространенных операций уже созданы предопределенные коллекторы. К ним можно получить доступ с помощью типа Collectors.</p>

<p>В этом разделе мы будем использовать следующий список в качестве источника для всех потоков:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">productList</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="k">new</span> <span class="nc">Product</span><span class="o">(</span><span class="mi">23</span><span class="o">,</span> <span class="s">"potatoes"</span><span class="o">),</span>
  <span class="k">new</span> <span class="nf">Product</span><span class="o">(</span><span class="mi">14</span><span class="o">,</span> <span class="s">"orange"</span><span class="o">),</span> <span class="k">new</span> <span class="nc">Product</span><span class="o">(</span><span class="mi">13</span><span class="o">,</span> <span class="s">"lemon"</span><span class="o">),</span>
  <span class="k">new</span> <span class="nf">Product</span><span class="o">(</span><span class="mi">23</span><span class="o">,</span> <span class="s">"bread"</span><span class="o">),</span> <span class="k">new</span> <span class="nc">Product</span><span class="o">(</span><span class="mi">13</span><span class="o">,</span> <span class="s">"sugar"</span><span class="o">));</span>
</code></pre></div></div>

<p>Преобразование потока в коллекцию (Collection, List или Set):</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">collectorCollection</span> <span class="o">=</span>
  <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">map</span><span class="o">(</span><span class="nl">Product:</span><span class="o">:</span><span class="n">getName</span><span class="o">).</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</code></pre></div></div>

<p>Объединение в строку:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">listToString</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">map</span><span class="o">(</span><span class="nl">Product:</span><span class="o">:</span><span class="n">getName</span><span class="o">)</span>
  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">joining</span><span class="o">(</span><span class="s">", "</span><span class="o">,</span> <span class="s">"["</span><span class="o">,</span> <span class="s">"]"</span><span class="o">));</span>
</code></pre></div></div>

<p>Метод <code class="language-plaintext highlighter-rouge">joiner()</code> может иметь от одного до трех параметров (разделитель, префикс, суффикс). Самое удобное в использовании <code class="language-plaintext highlighter-rouge">joiner()</code> заключается в том, что разработчику не нужно проверять, достигает ли поток своего конца, чтобы применить суффикс, а не разделитель. Коллектор позаботится об этом.</p>

<p>Обработка среднего значения всех числовых элементов потока:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="n">averagePrice</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">averagingInt</span><span class="o">(</span><span class="nl">Product:</span><span class="o">:</span><span class="n">getPrice</span><span class="o">));</span>
</code></pre></div></div>

<p>Обработка суммы всех числовых элементов потока:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">summingPrice</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">summingInt</span><span class="o">(</span><span class="nl">Product:</span><span class="o">:</span><span class="n">getPrice</span><span class="o">));</span>
</code></pre></div></div>

<p>Методы <code class="language-plaintext highlighter-rouge">averagingXX()</code>, <code class="language-plaintext highlighter-rouge">summingXX()</code> и <code class="language-plaintext highlighter-rouge">summarizingXX()</code> могут работать с примитивами (int, long, double) и с их классами-оболочками (Integer, Long, Double). Еще одной мощной функцией этих методов является обеспечение маппинга. В результате разработчику не нужно использовать дополнительную операцию <code class="language-plaintext highlighter-rouge">map()</code> перед методом <code class="language-plaintext highlighter-rouge">collect()</code>.</p>

<p>Сбор статистической информации об элементах stream:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IntSummaryStatistics</span> <span class="n">statistics</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">summarizingInt</span><span class="o">(</span><span class="nl">Product:</span><span class="o">:</span><span class="n">getPrice</span><span class="o">));</span>
</code></pre></div></div>

<p>Используя результирующий экземпляр типа IntSummaryStatistics, разработчик может создать статистический отчет, применив метод <code class="language-plaintext highlighter-rouge">toString()</code>. Результатом будет строка, похожая на “IntSummaryStatistics{count=5, sum=86, min=13, average=17200000, max=23}.”</p>

<p>Также легко извлечь из этого объекта отдельные значения для count, sum, min, и average, применив методы <code class="language-plaintext highlighter-rouge">getCount()</code>, <code class="language-plaintext highlighter-rouge">getSum()</code>, <code class="language-plaintext highlighter-rouge">getMin()</code>, <code class="language-plaintext highlighter-rouge">getAverage()</code>, и <code class="language-plaintext highlighter-rouge">getMax()</code>. Все эти значения могут быть извлечены из одного конвейера.</p>

<p>Группировка элементов stream в соответствии с указанной функцией:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;&gt;</span> <span class="n">collectorMapOfLists</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">groupingBy</span><span class="o">(</span><span class="nl">Product:</span><span class="o">:</span><span class="n">getPrice</span><span class="o">));</span>
</code></pre></div></div>

<p>В приведенном выше примере поток был сведен к Map, который группирует все продукты по их цене.</p>

<p>Разделение элементов stream на группы в соответствии с некоторым предикатом:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Boolean</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;&gt;</span> <span class="n">mapPartioned</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">partitioningBy</span><span class="o">(</span><span class="n">element</span> <span class="o">-&gt;</span> <span class="n">element</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">15</span><span class="o">));</span>
</code></pre></div></div>

<p>Этот код использует потоки данных (Streams) для разделения списка продуктов (productList) на две группы на основе цены продукта. Результатом будет Map, где ключами являются Boolean значения (true или false), а значениями — списки продуктов, соответствующие этим ключам.</p>

<p>Приведение коллектора к дополнительному преобразованию:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">unmodifiableSet</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">collectingAndThen</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toSet</span><span class="o">(),</span>
  <span class="nl">Collections:</span><span class="o">:</span><span class="n">unmodifiableSet</span><span class="o">));</span>
</code></pre></div></div>

<p>В данном конкретном случае сборщик преобразовал stream в Set, а затем создал из него неизменяемый Set.</p>

<p>Кастомный сборщик:</p>

<p>Если по какой-либо причине необходимо создать кастомный коллектор, самый простой и наименее подробный способ сделать это - использовать метод <code class="language-plaintext highlighter-rouge">of()</code> типа Collector.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Collector</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">,</span> <span class="o">?,</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;&gt;</span> <span class="n">toLinkedList</span> <span class="o">=</span>
  <span class="nc">Collector</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="nl">LinkedList:</span><span class="o">:</span><span class="k">new</span><span class="o">,</span> <span class="nl">LinkedList:</span><span class="o">:</span><span class="n">add</span><span class="o">,</span>
    <span class="o">(</span><span class="n">first</span><span class="o">,</span> <span class="n">second</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
       <span class="n">first</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">second</span><span class="o">);</span>
       <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">});</span>

<span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">linkedListOfPersons</span> <span class="o">=</span>
  <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span><span class="n">toLinkedList</span><span class="o">);</span>
</code></pre></div></div>

<p>Метод <code class="language-plaintext highlighter-rouge">of()</code> используется для создания экземпляра Collector. Первым аргументом является функция, которая создает аккумулятор (в нашем случае, новый LinkedList). Вторым аргументом — функция, которая добавляет элемент в аккумулятор. Третий аргумент — функция, объединяющая два аккумулятора в один. В данном случае, она просто добавляет все элементы из второго аккумулятора в первый. В этом примере экземпляр коллектора был объединен в <code class="language-plaintext highlighter-rouge">LinkedList&lt;Product&gt;</code>.</p>

<h2 id="7-параллельные-потоки">7. Параллельные потоки</h2>

<p>До появления Java 8 распараллеливание было сложным. Появление ExecutorService и forkJoin немного упростило жизнь разработчику, но все же стоило запомнить, как создать конкретный исполнитель, как его запускать и так далее. В Java 8 представлен способ реализации параллелизма в функциональном стиле.</p>

<p>API позволяет нам создавать параллельные потоки, которые выполняют операции в параллельном режиме. Если источником потока является коллекция или массив, этого можно достичь с помощью метода <code class="language-plaintext highlighter-rouge">parallelStream()</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">streamOfCollection</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">parallelStream</span><span class="o">();</span>
<span class="kt">boolean</span> <span class="n">isParallel</span> <span class="o">=</span> <span class="n">streamOfCollection</span><span class="o">.</span><span class="na">isParallel</span><span class="o">();</span>
<span class="kt">boolean</span> <span class="n">bigPrice</span> <span class="o">=</span> <span class="n">streamOfCollection</span>
  <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">product</span> <span class="o">-&gt;</span> <span class="n">product</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()</span> <span class="o">*</span> <span class="mi">12</span><span class="o">)</span>
  <span class="o">.</span><span class="na">anyMatch</span><span class="o">(</span><span class="n">price</span> <span class="o">-&gt;</span> <span class="n">price</span> <span class="o">&gt;</span> <span class="mi">200</span><span class="o">);</span>
</code></pre></div></div>

<p>Если источником потока является нечто иное, чем коллекция или массив, следует использовать метод <code class="language-plaintext highlighter-rouge">parallel()</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IntStream</span> <span class="n">intStreamParallel</span> <span class="o">=</span> <span class="nc">IntStream</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">150</span><span class="o">).</span><span class="na">parallel</span><span class="o">();</span>
<span class="kt">boolean</span> <span class="n">isParallel</span> <span class="o">=</span> <span class="n">intStreamParallel</span><span class="o">.</span><span class="na">isParallel</span><span class="o">();</span>
</code></pre></div></div>

<p>По сути, Stream API автоматически использует платформу forkJoin для параллельного выполнения операций. По умолчанию будет использоваться общий пул потоков.</p>

<p>При использовании потоков в параллельном режиме избегайте блокирования операций. Также лучше использовать параллельный режим, когда для выполнения задач требуется аналогичное количество времени. Если одна задача длится намного дольше другой, это может замедлить рабочий процесс всего приложения.</p>

<p>Поток в параллельном режиме может быть преобразован обратно в последовательный режим с помощью метода <code class="language-plaintext highlighter-rouge">sequential()</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IntStream</span> <span class="n">intStreamSequential</span> <span class="o">=</span> <span class="n">intStreamParallel</span><span class="o">.</span><span class="na">sequential</span><span class="o">();</span>
<span class="kt">boolean</span> <span class="n">isParallel</span> <span class="o">=</span> <span class="n">intStreamSequential</span><span class="o">.</span><span class="na">isParallel</span><span class="o">();</span>
</code></pre></div></div>

<h2 id="8-заключение">8. Заключение</h2>

<p>Stream API - это мощный, но простой для понимания набор инструментов для обработки последовательности элементов. При правильном использовании это позволяет нам сократить огромное количество шаблонного кода, создавать более читаемые программы и повышать производительность приложения.</p>

<p>В большинстве примеров кода, показанных в этой статье, мы оставили потоки неиспользованными (мы не применяли метод <code class="language-plaintext highlighter-rouge">close()</code> или терминальную операцию). В реальном приложении не оставляйте созданный поток неиспользованным, так как это приведет к утечке памяти.</p>

<p><a href="https://www.baeldung.com/java-8-streams">оригинал</a></p>]]></content><author><name>Ринат Мамбетов</name></author><category term="java" /><category term="stream" /><summary type="html"><![CDATA[В этом руководстве рассматривается практическое использование Java 8 Streams от создания до параллельного выполнения.]]></summary></entry></feed>