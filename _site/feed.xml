<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-11-10T14:45:09+03:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Мой блог о программировании</title><subtitle>Dive into the world of programming with my latest blog post</subtitle><author><name>Ринат Мамбетов</name></author><entry><title type="html">Обзор Spring Bean</title><link href="http://localhost:4000/spring/2024/07/26/spring-bean-overview.html" rel="alternate" type="text/html" title="Обзор Spring Bean" /><published>2024-07-26T18:18:05+03:00</published><updated>2024-07-26T18:18:05+03:00</updated><id>http://localhost:4000/spring/2024/07/26/spring-bean-overview</id><content type="html" xml:base="http://localhost:4000/spring/2024/07/26/spring-bean-overview.html"><![CDATA[<p>Контейнер IoC Spring управляет одним или несколькими бинами. Эти бины создаются с использованием метаданных конфигурации, которые вы предоставляете контейнеру (например, в виде определений <code class="language-plaintext highlighter-rouge">&lt;bean/&gt;</code> в XML).</p>

<h2 id="обзор-бинов">Обзор бинов</h2>

<p>Внутри самого контейнера эти определения бинов представлены как объекты BeanDefinition, которые содержат (среди прочей информации) следующие метаданные:</p>

<ul>
  <li>Квалифицированное имя класса пакета: обычно это фактический класс реализации определяемого бина.</li>
  <li>Элементы конфигурации поведения бина, которые указывают, как бин должен вести себя в контейнере (область видимости, обратные вызовы жизненного цикла и т. д.).</li>
  <li>Ссылки на другие бины, которые необходимы для работы данного бина. Эти ссылки также называются сотрудниками или зависимостями.</li>
  <li>Другие настройки конфигурации, которые необходимо установить в вновь созданном объекте, например, лимит размера пула или количество соединений, которые следует использовать в бине, управляющем пулом соединений.</li>
</ul>

<p>В дополнение к определениям бинов, которые содержат информацию о том, как создать конкретный бин, реализации ApplicationContext также позволяют регистрировать существующие объекты, созданные вне контейнера (пользователями). Это делается путем доступа к BeanFactory ApplicationContext через метод getBeanFactory(), который возвращает реализацию DefaultListableBeanFactory. DefaultListableBeanFactory поддерживает эту регистрацию через методы registerSingleton(..) и registerBeanDefinition(..). Однако типичные приложения работают исключительно с бинами, определенными через обычные метаданные определения бинов.</p>

<p>Метаданные бинов и вручную предоставленные экземпляры синглтонов необходимо регистрировать как можно раньше, чтобы контейнер мог правильно обрабатывать их во время автозаполнения и других этапов интроспекции. Хотя переопределение существующих метаданных и существующих экземпляров синглтонов поддерживается в определенной степени, регистрация новых бинов во время выполнения (параллельно с активным доступом к фабрике) официально не поддерживается и может привести к исключениям параллельного доступа, несогласованному состоянию в контейнере бинов или тому и другому.</p>

<h2 id="переопределение-бинов">Переопределение бинов</h2>

<p>Переопределение бина происходит, когда бин регистрируется с использованием идентификатора, который уже был выделен. Хотя переопределение бинов возможно, оно усложняет чтение конфигурации, и эта функция будет устаревать в будущих релизах.</p>

<p>Чтобы полностью отключить переопределение бинов, вы можете установить флаг allowBeanDefinitionOverriding в значение false в ApplicationContext до его обновления. В таком случае будет выброшено исключение, если будет использовано переопределение бина.</p>

<p>По умолчанию контейнер регистрирует каждое переопределение бина на уровне INFO, чтобы вы могли соответственно адаптировать свою конфигурацию. Хотя это не рекомендуется, вы можете отключить эти логи, установив флаг allowBeanDefinitionOverriding в значение true.</p>

<h2 id="java-конфигурация">Java-конфигурация</h2>

<p>Если вы используете Java-конфигурацию, соответствующий метод @Bean всегда тихо переопределяет сканируемый класс бина с тем же именем компонента, если тип возвращаемого значения метода @Bean совпадает с классом бина. Это просто означает, что контейнер будет вызывать метод фабрики @Bean в пользу любого заранее объявленного конструктора класса бина.</p>

<h2 id="именование-бинов">Именование бинов</h2>

<p>Каждый бин имеет один или несколько идентификаторов. Эти идентификаторы должны быть уникальными в контейнере, который содержит бин. Обычно у бина есть только один идентификатор. Однако, если требуется больше одного, дополнительные могут считаться псевдонимами.</p>

<p>В метаданных конфигурации на основе XML вы используете атрибут id, атрибут name или оба, чтобы указать идентификаторы бинов. Атрибут id позволяет указать ровно один id. Обычно эти имена являются алфавитно-цифровыми (‘myBean’, ‘someService’ и т. д.), но они также могут содержать специальные символы. Если вы хотите ввести другие псевдонимы для бина, вы также можете указать их в атрибуте name, разделяя запятой (,), точкой с запятой (;) или пробелом. Хотя атрибут id определен как тип xsd:string, уникальность id бина обеспечивается контейнером, но не XML-парсерами.</p>

<p>Вы не обязаны предоставлять имя или id для бина. Если вы не укажете имя или id явно, контейнер сгенерирует уникальное имя для этого бина. Однако, если вы хотите ссылаться на этот бин по имени, используя элемент ref или поиск в стиле Service Locator, вы должны предоставить имя. Мотивации для неуказания имени связаны с использованием внутренних бинов и автозаполнением сотрудников.</p>

<h2 id="конвенции-именования-бинов">Конвенции именования бинов</h2>

<p>Конвенция заключается в использовании стандартной Java-конвенции для имен полей экземпляров при именовании бинов. То есть, имена бинов начинаются с маленькой буквы и далее записываются в camelCase. Примеры таких имен включают accountManager, accountService, userDao, loginController и т. д.</p>

<p>Последовательное именование бинов делает вашу конфигурацию более читаемой и понятной. Кроме того, если вы используете Spring AOP, это значительно упрощает применение советов к набору бинов, связанных по имени.</p>

<p>С помощью сканирования компонентов в classpath Spring генерирует имена бинов для неназванных компонентов, следуя описанным ранее правилам: по сути, берется простое имя класса и его первый символ преобразуется в строчную букву. Однако в (необычном) специальном случае, когда более одного символа и оба первых символа являются заглавными, оригинальный регистр сохраняется. Это те же правила, которые определены в java.beans.Introspector.decapitalize (которые Spring использует в данном случае).</p>

<h2 id="алиас-бина-вне-определения-бина">Алиас бина вне определения бина</h2>

<p>В самом определении бина вы можете указать более одного имени для бина, используя комбинацию из одного имени, указанного в атрибуте id, и любого количества других имен в атрибуте name. Эти имена могут быть эквивалентными алиасами для одного и того же бина и полезны в некоторых ситуациях, например, позволяя каждому компоненту в приложении ссылаться на общую зависимость, используя имя бина, специфичное для этого компонента.</p>

<p>Однако указание всех алиасов там, где бин фактически определен, не всегда является достаточным. Иногда необходимо ввести алиас для бина, который определен в другом месте. Это часто встречается в крупных системах, где конфигурация разделена между каждой подсистемой, и каждая подсистема имеет свой собственный набор определений объектов. В метаданных конфигурации на основе XML вы можете использовать элемент <code class="language-plaintext highlighter-rouge">&lt;alias/&gt;</code>, чтобы достичь этого. Следующий пример показывает, как это сделать:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;alias</span> <span class="na">name=</span><span class="s">"fromName"</span> <span class="na">alias=</span><span class="s">"toName"</span><span class="nt">/&gt;</span>
</code></pre></div></div>

<p>В этом случае бин (в том же контейнере) с именем fromName также может, после использования этого определения алиаса, быть упомянут как toName.</p>

<p>Например, метаданные конфигурации для подсистемы A могут ссылаться на DataSource под именем subsystemA-dataSource. Метаданные конфигурации для подсистемы B могут ссылаться на DataSource под именем subsystemB-dataSource. При составлении основного приложения, которое использует обе эти подсистемы, основное приложение ссылается на DataSource под именем myApp-dataSource. Чтобы все три имени ссылались на один и тот же объект, вы можете добавить следующие определения алиасов в метаданные конфигурации:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;alias</span> <span class="na">name=</span><span class="s">"myApp-dataSource"</span> <span class="na">alias=</span><span class="s">"subsystemA-dataSource"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;alias</span> <span class="na">name=</span><span class="s">"myApp-dataSource"</span> <span class="na">alias=</span><span class="s">"subsystemB-dataSource"</span><span class="nt">/&gt;</span>
</code></pre></div></div>

<p>Теперь каждый компонент и основное приложение могут ссылаться на dataSource через имя, которое уникально и гарантированно не будет конфликтовать с любым другим определением (фактически создавая пространство имен), при этом они ссылаются на один и тот же бин.</p>

<p>Если вы используете Java-конфигурацию, аннотация @Bean может быть использована для предоставления алиасов.</p>

<h2 id="создание-бинов">Создание бинов</h2>

<p>Определение бина по сути является рецептом для создания одного или нескольких объектов. Контейнер обращается к рецепту для именованного бина по запросу и использует метаданные конфигурации, инкапсулированные в этом определении бина, для создания (или получения) фактического объекта.</p>

<p>Если вы используете метаданные конфигурации на основе XML, вы указываете тип (или класс) объекта, который должен быть создан, в атрибуте class элемента <code class="language-plaintext highlighter-rouge">&lt;bean/&gt;</code>. Этот атрибут class (который внутренне является свойством Class в экземпляре BeanDefinition) обычно является обязательным. Вы можете использовать свойство Class одним из двух способов:</p>

<ol>
  <li>
    <p>Обычно, чтобы указать класс бина, который будет создан в случае, если контейнер сам непосредственно создает бин, вызывая его конструктор рефлексивно, что несколько эквивалентно коду Java с оператором new.</p>
  </li>
  <li>
    <p>Чтобы указать фактический класс, содержащий статический метод фабрики, который вызывается для создания объекта, в менее распространенном случае, когда контейнер вызывает статический метод фабрики на классе для создания бина. Тип объекта, возвращаемый при вызове статического метода фабрики, может быть тем же классом или совершенно другим классом.</p>
  </li>
</ol>

<h2 id="имена-вложенных-классов">Имена вложенных классов</h2>

<p>Если вы хотите настроить определение бина для вложенного класса, вы можете использовать либо двоичное имя, либо исходное имя вложенного класса.</p>

<p>Например, если у вас есть класс под названием SomeThing в пакете com.example, и этот класс SomeThing имеет статический вложенный класс под названием OtherThing, они могут быть разделены знаком доллара ($) или точкой (.). Таким образом, значение атрибута class в определении бина будет com.example.SomeThing$OtherThing или com.example.SomeThing.OtherThing.</p>

<h2 id="создание-с-помощью-конструктора">Создание с помощью конструктора</h2>

<p>Когда вы создаете бин с помощью подхода конструктора, все обычные классы могут использоваться и совместимы с Spring. То есть класс, который разрабатывается, не должен реализовывать какие-либо специфические интерфейсы или быть закодированным определенным образом. Достаточно просто указать класс бина. Однако в зависимости от того, какой тип IoC вы используете для этого конкретного бина, вам может понадобиться конструктор по умолчанию (пустой).</p>

<p>Контейнер IoC Spring может управлять практически любым классом, который вы хотите, чтобы он управлял. Он не ограничен управлением истинными JavaBeans. Большинство пользователей Spring предпочитают настоящие JavaBeans с только конструктором по умолчанию (без аргументов) и соответствующими сеттерами и геттерами, смоделированными по свойствам в контейнере. Вы также можете иметь более экзотические классы, не соответствующие стилю бина, в вашем контейнере. Если, например, вам нужно использовать устаревший пул соединений, который абсолютно не соответствует спецификации JavaBean, Spring также может управлять им.</p>

<p>С помощью метаданных конфигурации на основе XML вы можете указать ваш класс бина следующим образом:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"exampleBean"</span> <span class="na">class=</span><span class="s">"examples.ExampleBean"</span><span class="nt">/&gt;</span>

<span class="nt">&lt;bean</span> <span class="na">name=</span><span class="s">"anotherExample"</span> <span class="na">class=</span><span class="s">"examples.ExampleBeanTwo"</span><span class="nt">/&gt;</span>
</code></pre></div></div>

<p>Для получения подробной информации о механизме передачи аргументов в конструктор (если это необходимо) и установки свойств экземпляра объекта после его создания.</p>

<p>В случае аргументов конструктора контейнер может выбрать соответствующий конструктор среди нескольких перегруженных конструкторов. Тем не менее, чтобы избежать неоднозначностей, рекомендуется сохранять сигнатуры ваших конструкторов как можно более простыми.</p>

<h2 id="создание-с-помощью-статического-метода-фабрики">Создание с помощью статического метода фабрики</h2>

<p>При определении бина, который вы создаете с помощью статического метода фабрики, используйте атрибут class, чтобы указать класс, содержащий статический метод фабрики, и атрибут с именем factory-method, чтобы указать имя самого метода фабрики. Вы должны иметь возможность вызвать этот метод (с необязательными аргументами, как описано позже) и вернуть живой объект, который затем будет рассматриваться так, как если бы он был создан через конструктор. Одно из применений такого определения бина — это вызов статических фабрик в устаревшем коде.</p>

<p>Следующее определение бина указывает, что бин будет создан путем вызова метода фабрики. Определение не указывает тип (класс) возвращаемого объекта, а скорее класс, содержащий метод фабрики. В этом примере метод createInstance() должен быть статическим методом. Следующий пример показывает, как указать метод фабрики:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"clientService"</span>
	<span class="na">class=</span><span class="s">"examples.ClientService"</span>
	<span class="na">factory-method=</span><span class="s">"createInstance"</span><span class="nt">/&gt;</span>
</code></pre></div></div>

<p>Следующий пример показывает класс, который будет работать с предыдущим определением бина:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ClientService</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="kd">static</span> <span class="nc">ClientService</span> <span class="n">clientService</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ClientService</span><span class="o">();</span>
	<span class="kd">private</span> <span class="nf">ClientService</span><span class="o">()</span> <span class="o">{}</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="nc">ClientService</span> <span class="nf">createInstance</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">clientService</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>В случае аргументов метода фабрики контейнер может выбрать соответствующий метод среди нескольких перегруженных методов с одинаковым именем. Тем не менее, чтобы избежать неоднозначностей, рекомендуется сохранять сигнатуры ваших методов фабрики как можно более простыми.</p>

<p>Типичный проблемный случай с перегрузкой методов фабрики — это Mockito с его многочисленными перегрузками метода mock. Выбирайте наиболее специфичный вариант mock, который возможен:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"clientService"</span> <span class="na">class=</span><span class="s">"org.mockito.Mockito"</span> <span class="na">factory-method=</span><span class="s">"mock"</span><span class="nt">&gt;</span>
	<span class="nt">&lt;constructor-arg</span> <span class="na">type=</span><span class="s">"java.lang.Class"</span> <span class="na">value=</span><span class="s">"examples.ClientService"</span><span class="nt">/&gt;</span>
	<span class="nt">&lt;constructor-arg</span> <span class="na">type=</span><span class="s">"java.lang.String"</span> <span class="na">value=</span><span class="s">"clientService"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</code></pre></div></div>

<h2 id="создание-с-использованием-метода-фабрики-экземпляра">Создание с использованием метода фабрики экземпляра</h2>

<p>Аналогично созданию через статический метод фабрики, создание с помощью метода фабрики экземпляра вызывает нестатический метод существующего бина из контейнера для создания нового бина. Чтобы использовать этот механизм, оставьте атрибут class пустым, а в атрибуте factory-bean укажите имя бина в текущем (или родительском, или предковом) контейнере, который содержит экземпляр метода, который будет вызван для создания объекта. Установите имя самого метода фабрики с помощью атрибута factory-method. Следующий пример показывает, как настроить такой бин:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- the factory bean, which contains a method called createClientServiceInstance() --&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"serviceLocator"</span> <span class="na">class=</span><span class="s">"examples.DefaultServiceLocator"</span><span class="nt">&gt;</span>
	<span class="c">&lt;!-- inject any dependencies required by this locator bean --&gt;</span>
<span class="nt">&lt;/bean&gt;</span>

<span class="c">&lt;!-- the bean to be created via the factory bean --&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"clientService"</span>
	<span class="na">factory-bean=</span><span class="s">"serviceLocator"</span>
	<span class="na">factory-method=</span><span class="s">"createClientServiceInstance"</span><span class="nt">/&gt;</span>
</code></pre></div></div>

<p>Следующий пример показывает соответствующий класс:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DefaultServiceLocator</span> <span class="o">{</span>

	<span class="kd">private</span> <span class="kd">static</span> <span class="nc">ClientService</span> <span class="n">clientService</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ClientServiceImpl</span><span class="o">();</span>

	<span class="kd">public</span> <span class="nc">ClientService</span> <span class="nf">createClientServiceInstance</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">clientService</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Один класс фабрики также может содержать более одного метода фабрики, как показывает следующий пример:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"serviceLocator"</span> <span class="na">class=</span><span class="s">"examples.DefaultServiceLocator"</span><span class="nt">&gt;</span>
	<span class="c">&lt;!-- inject any dependencies required by this locator bean --&gt;</span>
<span class="nt">&lt;/bean&gt;</span>

<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"clientService"</span>
	<span class="na">factory-bean=</span><span class="s">"serviceLocator"</span>
	<span class="na">factory-method=</span><span class="s">"createClientServiceInstance"</span><span class="nt">/&gt;</span>

<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"accountService"</span>
	<span class="na">factory-bean=</span><span class="s">"serviceLocator"</span>
	<span class="na">factory-method=</span><span class="s">"createAccountServiceInstance"</span><span class="nt">/&gt;</span>
</code></pre></div></div>

<p>В следующем примере показан соответствующий класс:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DefaultServiceLocator</span> <span class="o">{</span>

	<span class="kd">private</span> <span class="kd">static</span> <span class="nc">ClientService</span> <span class="n">clientService</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ClientServiceImpl</span><span class="o">();</span>

	<span class="kd">private</span> <span class="kd">static</span> <span class="nc">AccountService</span> <span class="n">accountService</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AccountServiceImpl</span><span class="o">();</span>

	<span class="kd">public</span> <span class="nc">ClientService</span> <span class="nf">createClientServiceInstance</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">clientService</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="nc">AccountService</span> <span class="nf">createAccountServiceInstance</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">accountService</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Этот подход показывает, что фабричный бин сам может управляться и настраиваться через внедрение зависимостей (DI).</p>

<p>В документации Spring “фабричный бин” относится к бину, который настроен в контейнере Spring и который создает объекты через нестатический или статический метод фабрики. В отличие от этого, FactoryBean (обратите внимание на заглавные буквы) относится к классу реализации FactoryBean, специфичному для Spring.</p>

<h2 id="определение-времени-выполнения-типа-бина">Определение времени выполнения типа бина</h2>

<p>Определить тип конкретного бина во время выполнения не так просто. Указанный класс в метаданных определения бина является лишь начальной ссылкой на класс, потенциально комбинируемой с объявленным методом фабрики или являющейся классом FactoryBean, что может привести к другому типу бина во время выполнения, или вообще не устанавливаться в случае метода фабрики на уровне экземпляра (который разрешается через указанное имя factory-bean). Кроме того, проксирование AOP может обернуть экземпляр бина интерфейсным прокси с ограниченным доступом к фактическому типу целевого бина (только его реализованным интерфейсам).</p>

<p>Рекомендуемый способ узнать фактический тип во время выполнения конкретного бина — это вызов BeanFactory.getType для указанного имени бина. Это учитывает все вышеперечисленные случаи и возвращает тип объекта, который вызов BeanFactory.getBean вернет для того же имени бина.</p>

<p><a href="https://docs.spring.io/spring-framework/reference/core/beans/definition.html">оригинал</a></p>]]></content><author><name>Ринат Мамбетов</name></author><category term="spring" /><summary type="html"><![CDATA[Контейнер IoC Spring управляет одним или несколькими бинами. Эти бины создаются с использованием метаданных конфигурации, которые вы предоставляете контейнеру (например, в виде определений &lt;bean/&gt; в XML).]]></summary></entry><entry><title type="html">Spring IoC Container</title><link href="http://localhost:4000/spring/2024/07/19/spring-container-overview.html" rel="alternate" type="text/html" title="Spring IoC Container" /><published>2024-07-19T18:18:05+03:00</published><updated>2024-07-19T18:18:05+03:00</updated><id>http://localhost:4000/spring/2024/07/19/spring-container-overview</id><content type="html" xml:base="http://localhost:4000/spring/2024/07/19/spring-container-overview.html"><![CDATA[<p>Интерфейс org.springframework.context.ApplicationContext представляет собой контейнер Spring IoC и отвечает за инстанцирование, конфигурацию и сборку бинов. Контейнер получает инструкции о компонентах, которые необходимо инстанцировать, конфигурировать и собирать, считывая метаданные конфигурации. Метаданные конфигурации могут быть представлены в виде аннотированных классов компонентов, классов конфигурации с фабричными методами или внешних XML-файлов или скриптов Groovy. В любом из этих форматов вы можете составить свое приложение и богатые взаимозависимости между этими компонентами.</p>

<h2 id="обзор-контейнера">Обзор контейнера</h2>

<p>Несколько реализаций интерфейса ApplicationContext являются частью основного Spring. В автономных приложениях обычно создается экземпляр AnnotationConfigApplicationContext или ClassPathXmlApplicationContext.</p>

<p>В большинстве сценариев приложений явный код пользователя не требуется для инстанцирования одного или нескольких экземпляров контейнера Spring IoC. Например, в простом веб-приложении достаточно простого шаблонного веб-дескриптора XML в файле web.xml приложения. В сценарии Spring Boot контекст приложения неявно инициализируется для вас на основе общих соглашений по настройке.</p>

<p>Следующая диаграмма показывает общее представление о том, как работает Spring. Ваши классы приложения комбинируются с метаданными конфигурации, так что после создания и инициализации ApplicationContext у вас есть полностью настроенная и исполняемая система или приложение.</p>

<!-- ![container-magic](https://docs.spring.io/spring-framework/reference/_images/container-magic.png) -->
<p><img src="/assets/images/container-magic.png" alt="container-magic" /></p>

<h2 id="метаданные-конфигурации">Метаданные конфигурации</h2>

<p>Как показано на предыдущей диаграмме, контейнер Spring IoC использует форму метаданных конфигурации. Эти метаданные конфигурации представляют собой способ, которым вы, как разработчик приложения, сообщаете контейнеру Spring, как инстанцировать, конфигурировать и собирать компоненты в вашем приложении.</p>

<p>Сам контейнер Spring IoC полностью отделен от формата, в котором эти метаданные конфигурации фактически написаны. В настоящее время многие разработчики выбирают конфигурацию на основе Java для своих приложений Spring:</p>

<ul>
  <li>
    <p>Конфигурация на основе аннотаций: определяйте бины, используя метаданные конфигурации на основе аннотаций в классах компонентов вашего приложения.</p>
  </li>
  <li>
    <p>Конфигурация на основе Java: определяйте бины вне классов вашего приложения, используя классы конфигурации на основе Java. Для использования этих функций смотрите аннотации @Configuration, @Bean, @Import и @DependsOn.</p>
  </li>
</ul>

<p>Конфигурация Spring состоит как минимум из одного, а обычно из более чем одного определения бина, которые контейнер должен управлять. Конфигурация на основе Java обычно использует методы, аннотированные @Bean, внутри класса @Configuration, каждый из которых соответствует одному определению бина.</p>

<p>Эти определения бинов соответствуют фактическим объектам, которые составляют ваше приложение. Обычно вы определяете объекты уровня сервиса, объекты уровня персистенции, такие как репозитории или объекты доступа к данным (DAO), объекты представления, такие как веб-контроллеры, инфраструктурные объекты, такие как JPA EntityManagerFactory, JMS-очереди и так далее. Обычно не настраивают детализированные доменные объекты в контейнере, поскольку обычно это ответственность репозиториев и бизнес-логики — создавать и загружать доменные объекты.</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;beans</span> <span class="na">xmlns=</span><span class="s">"http://www.springframework.org/schema/beans"</span>
	<span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
	<span class="na">xsi:schemaLocation=</span><span class="s">"http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd"</span><span class="nt">&gt;</span>

	<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"..."</span> <span class="na">class=</span><span class="s">"..."</span><span class="nt">&gt;</span>
		<span class="c">&lt;!-- collaborators and configuration for this bean go here --&gt;</span>
	<span class="nt">&lt;/bean&gt;</span>

	<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"..."</span> <span class="na">class=</span><span class="s">"..."</span><span class="nt">&gt;</span>
		<span class="c">&lt;!-- collaborators and configuration for this bean go here --&gt;</span>
	<span class="nt">&lt;/bean&gt;</span>

	<span class="c">&lt;!-- more bean definitions go here --&gt;</span>

<span class="nt">&lt;/beans&gt;</span>
</code></pre></div></div>

<h2 id="xml-как-внешний-dsl-конфигурации">XML как внешний DSL конфигурации</h2>

<p>Метаданные конфигурации на основе XML настраивают эти бины как элементы <code class="language-plaintext highlighter-rouge">&lt;bean/&gt;</code> внутри верхнего уровня элемента <code class="language-plaintext highlighter-rouge">&lt;beans/&gt;</code>. Следующий пример показывает основную структуру метаданных конфигурации на основе XML:</p>

<p>Атрибут id — это строка, которая идентифицирует отдельное определение бина.
Атрибут class определяет тип бина и использует полное имя класса.
Значение атрибута id может быть использовано для ссылки на объекты-сотрудники. XML для ссылки на объекты-сотрудники в этом примере не показан.</p>

<p>Для инстанцирования контейнера необходимо указать путь или пути к XML-ресурсам в конструкторе ClassPathXmlApplicationContext, который позволяет контейнеру загружать метаданные конфигурации из различных внешних ресурсов, таких как локальная файловая система, Java CLASSPATH и так далее.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="s">"services.xml"</span><span class="o">,</span> <span class="s">"daos.xml"</span><span class="o">);</span>
</code></pre></div></div>

<p>Следующий пример показывает файл конфигурации объектов уровня сервиса (services.xml):</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;beans</span> <span class="na">xmlns=</span><span class="s">"http://www.springframework.org/schema/beans"</span>
	<span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
	<span class="na">xsi:schemaLocation=</span><span class="s">"http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd"</span><span class="nt">&gt;</span>

	<span class="c">&lt;!-- services --&gt;</span>

	<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"petStore"</span> <span class="na">class=</span><span class="s">"org.springframework.samples.jpetstore.services.PetStoreServiceImpl"</span><span class="nt">&gt;</span>
		<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"accountDao"</span> <span class="na">ref=</span><span class="s">"accountDao"</span><span class="nt">/&gt;</span>
		<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"itemDao"</span> <span class="na">ref=</span><span class="s">"itemDao"</span><span class="nt">/&gt;</span>
		<span class="c">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span>
	<span class="nt">&lt;/bean&gt;</span>

	<span class="c">&lt;!-- more bean definitions for services go here --&gt;</span>

<span class="nt">&lt;/beans&gt;</span>
</code></pre></div></div>

<p>Следующий пример показывает файл daos.xml для объектов доступа к данным:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;beans</span> <span class="na">xmlns=</span><span class="s">"http://www.springframework.org/schema/beans"</span>
	<span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
	<span class="na">xsi:schemaLocation=</span><span class="s">"http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd"</span><span class="nt">&gt;</span>

	<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"accountDao"</span>
		<span class="na">class=</span><span class="s">"org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao"</span><span class="nt">&gt;</span>
		<span class="c">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span>
	<span class="nt">&lt;/bean&gt;</span>

	<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"itemDao"</span> <span class="na">class=</span><span class="s">"org.springframework.samples.jpetstore.dao.jpa.JpaItemDao"</span><span class="nt">&gt;</span>
		<span class="c">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span>
	<span class="nt">&lt;/bean&gt;</span>

	<span class="c">&lt;!-- more bean definitions for data access objects go here --&gt;</span>

<span class="nt">&lt;/beans&gt;</span>
</code></pre></div></div>

<p>В предыдущем примере уровень сервиса состоит из класса PetStoreServiceImpl и двух объектов доступа к данным типов JpaAccountDao и JpaItemDao (основанных на стандарте JPA для объектно-реляционного отображения). Элемент свойства name ссылается на имя свойства JavaBean, а элемент ref ссылается на имя другого определения бина. Эта связь между элементами id и ref выражает зависимость между сотрудничающими объектами.</p>

<h2 id="составление-метаданных-конфигурации-на-основе-xml">Составление метаданных конфигурации на основе XML</h2>

<p>Полезно, когда определения бинов охватывают несколько XML-файлов. Часто каждый отдельный файл конфигурации XML представляет собой логический уровень или модуль в вашей архитектуре.</p>

<p>Вы можете использовать конструктор ClassPathXmlApplicationContext для загрузки определений бинов из фрагментов XML. Этот конструктор принимает несколько местоположений ресурсов, как было показано в предыдущем разделе. В качестве альтернативы вы можете использовать одно или несколько вхождений элемента <code class="language-plaintext highlighter-rouge">****&lt;import/&gt;</code> для загрузки определений бинов из другого файла или файлов. Следующий пример показывает, как это сделать:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;beans&gt;</span>
	<span class="nt">&lt;import</span> <span class="na">resource=</span><span class="s">"services.xml"</span><span class="nt">/&gt;</span>
	<span class="nt">&lt;import</span> <span class="na">resource=</span><span class="s">"resources/messageSource.xml"</span><span class="nt">/&gt;</span>
	<span class="nt">&lt;import</span> <span class="na">resource=</span><span class="s">"/resources/themeSource.xml"</span><span class="nt">/&gt;</span>

	<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"bean1"</span> <span class="na">class=</span><span class="s">"..."</span><span class="nt">/&gt;</span>
	<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"bean2"</span> <span class="na">class=</span><span class="s">"..."</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/beans&gt;</span>
</code></pre></div></div>

<p>В предыдущем примере внешние определения бинов загружаются из трех файлов: services.xml, messageSource.xml и themeSource.xml. Все пути расположения относительны к файлу определения, который выполняет импорт, поэтому services.xml должен находиться в той же директории или класспасе, что и файл, выполняющий импорт, в то время как messageSource.xml и themeSource.xml должны находиться в расположении ресурсов ниже расположения импортирующего файла. Как видно, начальный слэш игнорируется. Однако, учитывая, что эти пути относительны, лучше вообще не использовать слэш. Содержимое импортируемых файлов, включая верхний уровень элемента <code class="language-plaintext highlighter-rouge">&lt;beans/&gt;</code>, должно быть действительными XML-определениями бинов в соответствии со схемой Spring.</p>

<p>Возможно, но не рекомендуется, ссылаться на файлы в родительских директориях, используя относительный путь “../”. Это создает зависимость от файла, который находится вне текущего приложения. В частности, такая ссылка не рекомендуется для URL-адресов classpath: (например, classpath:../services.xml), где процесс разрешения во время выполнения выбирает «ближайший» корень класспаса, а затем ищет в его родительской директории. Изменения конфигурации класспаса могут привести к выбору другой, неверной директории.</p>

<p>Вы всегда можете использовать полностью квалифицированные местоположения ресурсов вместо относительных путей: например, file:C:/config/services.xml или classpath:/config/services.xml. Однако имейте в виду, что вы связываете конфигурацию вашего приложения с конкретными абсолютными местоположениями. Обычно предпочтительнее сохранять косвенность для таких абсолютных местоположений — например, через заполнители “${…​}”, которые разрешаются в свойствах системы JVM во время выполнения.</p>

<p>Само пространство имен предоставляет возможность директивы импорта. Дополнительные функции конфигурации, помимо простых определений бинов, доступны в ряде XML-пространств имен, предоставляемых Spring, например, в пространствах имен context и util.</p>

<h2 id="dsl-определения-бинов-на-groovy">DSL определения бинов на Groovy</h2>

<p>В качестве еще одного примера для внешних метаданных конфигурации определения бинов также могут быть выражены в DSL определения бинов Groovy от Spring, известном из фреймворка Grails. Обычно такая конфигурация хранится в файле с расширением “.groovy” со структурой, показанной в следующем примере:</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">beans</span> <span class="o">{</span>
	<span class="n">dataSource</span><span class="o">(</span><span class="n">BasicDataSource</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">driverClassName</span> <span class="o">=</span> <span class="s2">"org.hsqldb.jdbcDriver"</span>
		<span class="n">url</span> <span class="o">=</span> <span class="s2">"jdbc:hsqldb:mem:grailsDB"</span>
		<span class="n">username</span> <span class="o">=</span> <span class="s2">"sa"</span>
		<span class="n">password</span> <span class="o">=</span> <span class="s2">""</span>
		<span class="n">settings</span> <span class="o">=</span> <span class="o">[</span><span class="nl">mynew:</span><span class="s2">"setting"</span><span class="o">]</span>
	<span class="o">}</span>
	<span class="n">sessionFactory</span><span class="o">(</span><span class="n">SessionFactory</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">dataSource</span> <span class="o">=</span> <span class="n">dataSource</span>
	<span class="o">}</span>
	<span class="n">myService</span><span class="o">(</span><span class="n">MyService</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">nestedBean</span> <span class="o">=</span> <span class="o">{</span> <span class="n">AnotherBean</span> <span class="n">bean</span> <span class="o">-&gt;</span>
			<span class="n">dataSource</span> <span class="o">=</span> <span class="n">dataSource</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Этот стиль конфигурации в значительной степени эквивалентен XML-определениям бинов и даже поддерживает XML-пространства имен конфигурации Spring. Он также позволяет импортировать файлы определения бинов XML через директиву importBeans.</p>

<p>Использование контейнера
ApplicationContext — это интерфейс для продвинутой фабрики, способной поддерживать реестр различных бинов и их зависимостей. Используя метод T getBean(String name, Class&lt;T&gt; requiredType), вы можете извлекать экземпляры ваших бинов.</p>

<p>ApplicationContext позволяет вам читать определения бинов и получать к ним доступ, как показано в следующем примере:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// create and configure beans</span>
<span class="nc">ApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="s">"services.xml"</span><span class="o">,</span> <span class="s">"daos.xml"</span><span class="o">);</span>

<span class="c1">// retrieve configured instance</span>
<span class="nc">PetStoreService</span> <span class="n">service</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"petStore"</span><span class="o">,</span> <span class="nc">PetStoreService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

<span class="c1">// use configured instance</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">userList</span> <span class="o">=</span> <span class="n">service</span><span class="o">.</span><span class="na">getUsernameList</span><span class="o">();</span>
</code></pre></div></div>

<p>С конфигурацией на Groovy процесс инициализации выглядит очень похоже. У него есть другой класс реализации контекста, который осведомлен о Groovy (но также понимает определения бинов XML). Следующий пример демонстрирует конфигурацию на Groovy:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GenericGroovyApplicationContext</span><span class="o">(</span><span class="s">"services.groovy"</span><span class="o">,</span> <span class="s">"daos.groovy"</span><span class="o">);</span>
</code></pre></div></div>

<p>Самый гибкий вариант — это GenericApplicationContext в сочетании с делегатами чтения, например, с XmlBeanDefinitionReader для XML-файлов, как показано в следующем примере:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">GenericApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GenericApplicationContext</span><span class="o">();</span>
<span class="k">new</span> <span class="nf">XmlBeanDefinitionReader</span><span class="o">(</span><span class="n">context</span><span class="o">).</span><span class="na">loadBeanDefinitions</span><span class="o">(</span><span class="s">"services.xml"</span><span class="o">,</span> <span class="s">"daos.xml"</span><span class="o">);</span>
<span class="n">context</span><span class="o">.</span><span class="na">refresh</span><span class="o">();</span>
</code></pre></div></div>

<p>Вы также можете использовать GroovyBeanDefinitionReader для файлов Groovy, как показано в следующем примере:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">GenericApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GenericApplicationContext</span><span class="o">();</span>
<span class="k">new</span> <span class="nf">GroovyBeanDefinitionReader</span><span class="o">(</span><span class="n">context</span><span class="o">).</span><span class="na">loadBeanDefinitions</span><span class="o">(</span><span class="s">"services.groovy"</span><span class="o">,</span> <span class="s">"daos.groovy"</span><span class="o">);</span>
<span class="n">context</span><span class="o">.</span><span class="na">refresh</span><span class="o">();</span>
</code></pre></div></div>

<p>Вы можете комбинировать такие делегаты чтения в одном ApplicationContext, считывая определения бинов из различных источников конфигурации.</p>

<p>Затем вы можете использовать метод getBean для извлечения экземпляров ваших бинов. Интерфейс ApplicationContext имеет несколько других методов для получения бинов, но, в идеале, ваш код приложения не должен их использовать. Действительно, ваш код приложения не должен содержать вызовов метода getBean() и, таким образом, не должен зависеть от API Spring. Например, интеграция Spring с веб-фреймворками предоставляет внедрение зависимостей для различных компонентов веб-фреймворков, таких как контроллеры и управляемые JSF-бины, позволяя вам объявлять зависимость от конкретного бина через метаданные (такие как аннотация автозаполнения).</p>

<p><a href="https://docs.spring.io/spring-framework/reference/core/beans/basics.html">оригинал</a></p>]]></content><author><name>Ринат Мамбетов</name></author><category term="spring" /><summary type="html"><![CDATA[Интерфейс org.springframework.context.ApplicationContext представляет собой контейнер Spring IoC и отвечает за инстанцирование, конфигурацию и сборку бинов. Контейнер получает инструкции о компонентах, которые необходимо инстанцировать, конфигурировать и собирать, считывая метаданные конфигурации. Метаданные конфигурации могут быть представлены в виде аннотированных классов компонентов, классов конфигурации с фабричными методами или внешних XML-файлов или скриптов Groovy. В любом из этих форматов вы можете составить свое приложение и богатые взаимозависимости между этими компонентами.]]></summary></entry><entry><title type="html">Руководство по томам Docker (Docker Volumes)</title><link href="http://localhost:4000/docker/2024/07/12/ops-docker-volumes.html" rel="alternate" type="text/html" title="Руководство по томам Docker (Docker Volumes)" /><published>2024-07-12T18:18:05+03:00</published><updated>2024-07-12T18:18:05+03:00</updated><id>http://localhost:4000/docker/2024/07/12/ops-docker-volumes</id><content type="html" xml:base="http://localhost:4000/docker/2024/07/12/ops-docker-volumes.html"><![CDATA[<p>Контейнеры — это изолированные среды в контексте системы Linux, которые могут выделять заранее определенные объемы конкретных ресурсов. Чаще всего контейнеры Docker используются для запуска приложений в изоляции. По умолчанию все изменения внутри контейнера теряются, когда контейнер останавливается. Если мы хотим сохранять данные между запусками, могут помочь тома Docker и bind mounts.</p>

<p>В этом руководстве мы узнаем о томах Docker и о том, как управлять ими и подключать к контейнерам.</p>

<h2 id="1-файловая-система-docker">1. Файловая система Docker</h2>

<p>Контейнеры Docker запускают программный стек, определенный в образе Docker. Образы состоят из набора слоев только для чтения, которые работают на файловой системе, называемой Union Filesystem. Когда мы запускаем новый контейнер, Docker добавляет слой с правами на запись поверх слоев образа, позволяя контейнеру работать так, как если бы он находился на стандартной файловой системе Linux.</p>

<p>Таким образом, любое изменение файла внутри контейнера создает рабочую копию в слое с правами на запись. Однако, когда контейнер останавливается или удаляется, этот слой с правами на запись теряется.</p>

<p><img src="/assets/images/layers.webp" alt="layers" /></p>

<p>Мы можем это проверить, выполнив команду, которая записывает файл, а затем читает его:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run bash:latest <span class="se">\</span>
  bash <span class="nt">-c</span> <span class="s2">"echo hello &gt; file.txt &amp;&amp; cat file.txt"</span>
</code></pre></div></div>

<p>В результате:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hello
</code></pre></div></div>

<p>Однако, если мы запустим тот же образ с командой, которая просто выводит содержимое того же файла, мы получим ошибку:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run bash:latest bash <span class="nt">-c</span> <span class="s2">"cat file.txt"</span>
<span class="nb">cat</span>: can<span class="s1">'t open '</span>file.txt<span class="s1">': No such file or directory
</span></code></pre></div></div>

<p>Второй запуск контейнера снова начинается с чистой файловой системы, поэтому файл не найден. Чтобы сохранить файлы между запусками контейнера, мы можем использовать тома.</p>

<h2 id="2-bind-mounts-против-томов-docker">2. Bind mounts против томов Docker</h2>

<p>Поскольку как bind mounts, так и тома Docker используются как средства для обеспечения постоянного хранения.</p>

<p>Тем не менее, многие реализации предлагают bind mounts:</p>

<ul>
  <li>Ядро Linux</li>
  <li>Виртуализационное программное обеспечение</li>
  <li>Фреймворки управления контейнерами</li>
  <li>Решения для резервного копирования</li>
</ul>

<p>В каждом случае они выполняют одну и ту же функцию: bind mounts монтируют файл или каталог внутри другого каталога. Фактически, результат можно рассматривать как так называемую junction-директорию. Однако монтирования используют другой механизм, который работает с удаленными местоположениями и различными протоколами. Когда речь идет о контейнерах, bind mounts открывают файл или каталог хоста для контейнера.</p>

<p>С другой стороны, том Docker использует специальный каталог хранения внутри дерева каталогов Docker на хосте. Каждый том является подкаталогом, который управляется Docker. По сути, внутренние реализации имеют решающее значение для этой процедуры.</p>

<p>Многие преимущества томов по сравнению с bind mounts вытекают из этого факта:</p>

<ul>
  <li>Поскольку они являются частью развертывания, тома часто легче мигрировать.</li>
  <li>Существуют команды для управления томами.</li>
  <li>В отличие от mounts, тома доступны как в средах Microsoft Windows, так и в Linux.</li>
  <li>Совместное использование томов между контейнерами безопаснее благодаря контролируемому доступу.</li>
</ul>

<p>В общем, bind mounts обычно гораздо более производительны и проще в настройке, но зависят от специфических функций ОС.</p>

<h2 id="3-тома-в-docker">3. Тома в Docker</h2>

<p>В Docker тома — это способы постоянного хранения данных между перезапусками контейнеров. Они могут быть нативными реализациями или простыми привязками.</p>

<h3 id="31-bind-mounts">3.1. Bind mounts</h3>

<p>Bind mounts Docker — это высокопроизводительное соединение между контейнером и каталогом на хост-машине. Оно позволяет хосту делиться своей файловой системой с контейнером, который может быть настроен как только для чтения, так и для чтения и записи.</p>

<p>Это позволяет нам использовать контейнер для запуска инструментов, которые мы не хотим устанавливать на хосте, и при этом работать с файлами хоста. Например, если мы хотим использовать пользовательскую версию bash для конкретного скрипта, мы можем выполнить этот скрипт внутри контейнера bash, смонтированного в текущий рабочий каталог:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">-v</span> <span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span>:/var/opt/project bash:latest <span class="se">\</span>
  bash <span class="nt">-c</span> <span class="s2">"echo Hello &gt; /var/opt/project/file.txt"</span>
</code></pre></div></div>

<p>Опция –v одинакова для всех форм монтирования. В данном случае привязка указывает источник как рабочий каталог хоста из вывода команды $(pwd), а целевую точку монтирования — как /var/opt/project внутри контейнера.</p>

<p>После выполнения этой команды мы должны найти файл file.txt в рабочем каталоге хост-машины, так как контейнер его создает. Это простой способ обеспечить постоянное хранение файлов между вызовами контейнера Docker. Тем не менее, это часто наиболее полезно, когда контейнер выполняет работу от имени хоста.</p>

<p>Одним из хороших примеров использования этого подхода является выполнение различных версий инструментов сборки языка в Docker, чтобы избежать конфликтующих установок на машине разработчика.</p>

<h3 id="32-тома-docker">3.2. Тома Docker</h3>

<p>Bind mounts использует файловую систему хоста, но тома Docker являются нативными для Docker. Данные хранятся где-то на хранилище, подключенном к хосту, чаще всего на локальной файловой системе. Сам том имеет жизненный цикл, который длиннее, чем у контейнера, что позволяет ему сохраняться до тех пор, пока он не станет ненужным. Тома могут быть общими между контейнерами.</p>

<p>В некоторых случаях том имеет форму, которая не может быть использована хостом напрямую.</p>

<h2 id="4-управление-томами">4. Управление томами</h2>

<p>Docker позволяет нам управлять томами с помощью набора команд docker volume. Например, мы можем дать тому явное имя, что приведет к созданию именованных томов, или сказать Docker сгенерировать случайное имя для анонимных томов.</p>

<h3 id="41-создание-томов">4.1. Создание томов</h3>

<p>Для начала мы создаем том, используя подкоманду create и передавая имя в качестве аргумента:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker volume create data_volume
data_volume
</code></pre></div></div>

<p>Если имя не указано, Docker генерирует случайное имя в виде хеш-идентификатора:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker volume create
d7fb659f9b2f6c6fd7b2c796a47441fa77c8580a080e50fb0b1582c8f602ae2f
</code></pre></div></div>

<p>Важно отметить, что это отличается от внутренней идентификации тома.</p>

<h3 id="42-список-томов">4.2. Список томов</h3>

<p>Подкоманда ls отображает все тома, известные Docker:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker volume <span class="nb">ls
</span>DRIVER 	VOLUME NAME
<span class="nb">local 	</span>data_volume
<span class="nb">local   </span>d7fb659f9b2f6c6fd7b2c796a47441fa77c8580a080e50fb0b1582c8f602ae2f
</code></pre></div></div>

<p>Кроме того, мы можем отфильтровать результаты, используя опцию -f или –filter и передавая параметры key=value для большей точности:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker volume <span class="nb">ls</span> <span class="nt">-f</span> <span class="nv">name</span><span class="o">=</span>data
DRIVER 	VOLUME NAME
<span class="nb">local 	</span>data_volume
</code></pre></div></div>

<p>Таким образом, мы получаем только те тома, которые имеют имя data.</p>

<h3 id="43-просмотр-томов">4.3. Просмотр томов</h3>

<p>Чтобы отобразить подробную информацию о одном или нескольких томов, мы используем подкоманду inspect:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker volume inspect ca808e6fd82590dd0858f8f2486d3fa5bdf7523ac61d525319742e892ef56f59
<span class="o">[</span>
  <span class="o">{</span>
    <span class="s2">"CreatedAt"</span>: <span class="s2">"2023-11-13T17:04:17Z"</span>,
    <span class="s2">"Driver"</span>: <span class="s2">"local"</span>,
    <span class="s2">"Labels"</span>: null,
    <span class="s2">"Mountpoint"</span>: <span class="s2">"/var/lib/docker/volumes/ca808e6fd82590dd0858f8f2486d3fa5bdf7523ac61d525319742e892ef56f59/_data"</span>,
    <span class="s2">"Name"</span>: <span class="s2">"ca808e6fd82590dd0858f8f2486d3fa5bdf7523ac61d525319742e892ef56f59"</span>,
    <span class="s2">"Options"</span>: null,
    <span class="s2">"Scope"</span>: <span class="s2">"local"</span>
  <span class="o">}</span>
<span class="o">]</span>
</code></pre></div></div>

<p>Важно отметить, что Драйвер тома описывает, как хост Docker находит том. Тома могут находиться на удаленном хранилище, например, через NFS. В данном случае том находится на локальном хранилище.</p>

<h3 id="44-удаление-томов">4.4. Удаление томов</h3>

<p>Чтобы удалить один или несколько томов по отдельности, мы можем использовать подкоманду rm:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker volume <span class="nb">rm </span>data_volume
data_volume
</code></pre></div></div>

<p>Это похоже на то, как мы управляем целыми контейнерами.</p>

<h3 id="45-очистка-томов">4.5. Очистка томов</h3>

<p>Конечно, мы можем удалить все неиспользуемые тома с помощью подкоманды prune:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker volume prune
WARNING! This will remove all <span class="nb">local </span>volumes not used by at least one container.
Are you sure you want to <span class="k">continue</span>? <span class="o">[</span>y/N] y
Deleted Volumes:
data_volume
</code></pre></div></div>

<p>Как и ожидалось, появляется запрос, подтверждающий действие.</p>

<h2 id="5-запуск-контейнера-с-томом">5. Запуск контейнера с томом</h2>

<p>Чтобы создать и запустить контейнер с томом, мы используем опцию -v с соответствующими значениями.</p>

<h3 id="51-использование--v">5.1. Использование -v</h3>

<p>Опция -v состоит из трех компонентов, разделенных двоеточиями:</p>

<ul>
  <li>исходный каталог или имя тома</li>
  <li>точка монтирования внутри контейнера</li>
  <li>(необязательно) ro, если монтирование должно быть только для чтения</li>
</ul>

<p>Как мы видели в предыдущем примере, мы можем запустить контейнер с привязанным монтированием через опцию -v:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">-v</span> <span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span>:/var/opt/project bash:latest <span class="se">\</span>
  bash <span class="nt">-c</span> <span class="s2">"ls /var/opt/project"</span>
</code></pre></div></div>

<p>Этот синтаксис также поддерживает монтирование нативного тома Docker:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">-v</span> data-volume:/var/opt/project bash:latest <span class="se">\</span>
  bash <span class="nt">-c</span> <span class="s2">"ls /var/opt/project"</span>
</code></pre></div></div>

<p>Поскольку этот конкретный том пуст, команда не выводит никаких данных.</p>

<p>Тем не менее, мы можем записать файл в том во время одного из вызовов контейнера:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">-v</span> data-volume:/var/opt/project bash:latest <span class="se">\</span>
  bash <span class="nt">-c</span> <span class="s2">"echo Rinat &gt; /var/opt/project/Rinat.txt"</span>
</code></pre></div></div>

<p>Затем последующие команды для доступа к этому же файлу должны завершиться успешно:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">-v</span> data-volume:/var/opt/project bash <span class="nt">-c</span> <span class="s2">"ls /var/opt/project"</span>
Rinat.txt
</code></pre></div></div>

<p>Таким образом, мы получаем доступ к одним и тем же данным между перезапусками контейнера.</p>

<h3 id="52-использование-опции-mount">5.2. Использование опции –mount</h3>

<p>В других случаях мы можем предпочесть использовать более понятную опцию –mount для указания тома, который мы хотим смонтировать:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">--mount</span> <span class="se">\</span>
  <span class="s1">'type=volume,src=data-volume,\
  dst=/var/opt/project,volume-driver=local,\
  readonly'</span> <span class="se">\</span>
  bash <span class="nt">-c</span> <span class="s2">"ls /var/opt/project"</span>
</code></pre></div></div>

<p>Значения для –mount состоят из строки пар ключ-значение, разделенных запятыми.</p>

<p>Давайте посмотрим, что мы установили:</p>

<ul>
  <li>type: тип монтирования, в данном случае том</li>
  <li>src: имя тома или исходный каталог, если создается привязка</li>
  <li>dst: точка назначения монтирования в контейнере</li>
  <li>volume-driver: какой драйвер тома использовать, при этом локальный драйвер работает с локальным хранилищем</li>
  <li>readonly: сделать монтирование только для чтения (rw позволяет чтение и запись)</li>
</ul>

<p>Важно отметить, что вышеуказанная команда также создает соответствующий том, если он еще не существует.</p>

<h3 id="53-использование-volumes-from-для-совместного-использования-томов">5.3. Использование –volumes-from для совместного использования томов</h3>

<p>Критически важно, что присоединение тома к контейнеру создает долгосрочное соединение между контейнером и этим томом. Даже когда контейнер завершил свою работу, это отношение все еще существует.</p>

<p>Из-за этого мы можем использовать завершенный контейнер в качестве шаблона для монтирования того же набора томов в новый контейнер.</p>

<p>Предположим, мы запускаем простой скрипт в контейнере с монтированием data-volume. Позже мы перечисляем все контейнеры, которые мы использовали:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker ps <span class="nt">-a</span>
CONTAINER ID   IMAGE             COMMAND                  CREATED              STATUS                          PORTS      NAMES
4920602f8048   bash              <span class="s2">"docker-entrypoint.s…"</span>   7 minutes ago        Exited <span class="o">(</span>0<span class="o">)</span> 7 minutes ago                   exciting_payne
</code></pre></div></div>

<p>После этого мы можем запустить следующий контейнер, скопировав тома, используемые в уже существующем контейнере:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">--volumes-from</span> 4920 <span class="se">\</span>
  bash:latest <span class="se">\</span>
  bash <span class="nt">-c</span> <span class="s2">"ls /var/opt/project"</span>
Rinat.txt
</code></pre></div></div>

<p>На практике –volumes-from обычно связывает тома между работающими контейнерами. Например, Jenkins использует это для совместного использования данных между агентами, работающими как контейнеры Docker.</p>

<h2 id="6-заключение">6. Заключение</h2>

<p>В этой статье мы рассмотрели, как Docker обычно создает контейнер с новой файловой системой и как bind mounts и тома обеспечивают долгосрочное хранение данных за пределами жизненного цикла контейнера.</p>

<p>Кроме того, мы изучили способы перечисления и управления томами Docker, а также как подключать тома к работающему контейнеру через командную строку.</p>

<p>В общем, знание того, как работать с постоянным хранилищем в Docker, имеет решающее значение для многих приложений, которые требуют согласованности.</p>

<p><a href="https://www.baeldung.com/ops/docker-volumes">оригинал</a></p>]]></content><author><name>Ринат Мамбетов</name></author><category term="docker" /><summary type="html"><![CDATA[Контейнеры — это изолированные среды в контексте системы Linux, которые могут выделять заранее определенные объемы конкретных ресурсов. Чаще всего контейнеры Docker используются для запуска приложений в изоляции. По умолчанию все изменения внутри контейнера теряются, когда контейнер останавливается. Если мы хотим сохранять данные между запусками, могут помочь тома Docker и bind mounts.]]></summary></entry><entry><title type="html">Руководство по Log4j и log4j.properties в Java</title><link href="http://localhost:4000/logging/2024/07/05/java-log4j-properties-guide.html" rel="alternate" type="text/html" title="Руководство по Log4j и log4j.properties в Java" /><published>2024-07-05T18:18:05+03:00</published><updated>2024-07-05T18:18:05+03:00</updated><id>http://localhost:4000/logging/2024/07/05/java-log4j-properties-guide</id><content type="html" xml:base="http://localhost:4000/logging/2024/07/05/java-log4j-properties-guide.html"><![CDATA[<p>Log4J — это популярный фреймворк для логирования с открытым исходным кодом, написанный на Java. Log4j широко используется в различных приложениях на Java. Более того, он является потокобезопасным, быстрым и предоставляет иерархию именованных логгеров. Log4j распространяется под лицензией Apache Software License с открытым исходным кодом.</p>

<p>Версия Log4j 1.x достигла конца своего жизненного цикла 5 августа 2015 года. Поэтому на сегодняшний день Log4j2 является последним обновлением Log4j.</p>

<p>В этом руководстве мы изучим Log4j и как настроить основные компоненты Log4j с помощью файла log4j.properties в Java.</p>

<h2 id="1-настройка-maven">1. Настройка Maven</h2>

<p>Для начала нам понадобится зависимость log4j-core в нашем файле pom.xml:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.apache.logging.log4j<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>log4j-api<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>2.24.1<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div>

<h2 id="2-api-log4j">2. API Log4j</h2>

<p>API Log4j предоставляет механизм для передачи информации о логировании на основе различных уровней приоритетов и направления её в различные назначения, такие как файлы, консоли, базы данных и т. д. Он также поддерживает фильтрацию лог-событий перед их передачей логгерам или аппендерам.</p>

<p>API Log4j имеет многослойную архитектуру, которая предоставляет два типа объектов в фреймворке Log4j — основные объекты и вспомогательные объекты.</p>

<h2 id="3-компоненты-log4j">3. Компоненты Log4j</h2>

<p>Существует три основных компонента Log4j — логгеры, аппендеры и макеты — которые могут использоваться вместе для вывода настраиваемых лог-сообщений в нужные назначения. Давайте рассмотрим их кратко.</p>

<h3 id="41-логгер">4.1. Логгер</h3>

<p>Объект Logger отвечает за представление информации о логировании. Это первый обязательный уровень в архитектуре Log4j. Класс Logger определён в пакете org.apache.log4j.</p>

<p>Как правило, мы создаём один экземпляр Logger для каждого класса приложения, чтобы логировать важные события, относящиеся к этому классу. Также мы обычно создаём этот экземпляр в начале класса, используя статический фабричный метод, который принимает имя класса в качестве параметра:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Logger</span> <span class="n">logger</span> <span class="o">=</span> <span class="nc">Logger</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="nc">JavaClass</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</code></pre></div></div>

<p>Затем мы можем использовать различные методы класса Logger для логирования или вывода важных событий в зависимости от их категорий. Эти методы включают trace(), debug(), info(), warn(), error(), fatal(). Эти методы определяют уровень запроса на логирование.</p>

<p>Приоритетный порядок методов Logger: TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL. Таким образом, эти методы выводят лог-сообщения в зависимости от уровня логгера, установленного в файле log4j.properties. Это означает, что если мы установим уровень логгера как INFO, то все события INFO, WARN, ERROR и FATAL будут записаны в лог.</p>

<h3 id="42-аппендер">4.2. Аппендер</h3>

<p>Аппендер обозначает назначение вывода логов. Мы можем выводить логи в несколько предпочтительных мест с помощью Log4j, таких как консоль, файлы, удалённый сокет-сервер, база данных и т. д. Мы называем эти выходные назначения аппендерами. Более того, мы можем прикрепить несколько аппендеров к логгеру.</p>

<p>Аппендеры работают в соответствии с правилом аддитивности аппендеров. Это правило гласит, что вывод лог-сообщения любого логгера будет направлен ко всем его аппендерам и его предкам — аппендерам, которые находятся выше в иерархии.</p>

<p>Log4j имеет несколько аппендеров, определённых для файлов, консольных выводов, GUI-компонентов, удалённых сокет-серверов, JMS и т. д.</p>

<h3 id="43-макет">4.3. Макет</h3>

<p>Мы используем макеты для настройки формата лог-сообщений. Мы можем сделать это, ассоциировав макет с уже определённым аппендером. Таким образом, комбинация макета и аппендеров помогает нам отправлять отформатированные лог-сообщения в нужные назначения.</p>

<p>Мы можем указать формат лог-сообщений, используя шаблоны преобразования. Класс PatternLayout объясняет больше о символах преобразования, которые мы можем использовать в зависимости от наших нужд.</p>

<p>Мы также рассмотрим несколько символов преобразования через примеры в следующих разделах.</p>

<h2 id="5-файл-log4jproperties">5. Файл log4j.properties</h2>

<p>Мы можем настроить Log4j с помощью XML или файла свойств. Файл log4j.properties хранит конфигурации в виде пар “ключ-значение”.</p>

<p>Имя файла конфигурации свойств log4j по умолчанию — log4j.properties. Логгер ищет это имя файла в CLASSPATH. Однако, если нам нужно использовать другое имя конфигурационного файла, мы можем установить его с помощью системного свойства log4j.configuration.</p>

<p>Файл log4j.properties содержит спецификации аппендеров, их имена и типы, а также шаблоны макетов. Он также содержит спецификации о корневом логгере по умолчанию и его уровнях логирования.</p>

<h2 id="6-синтаксис-файла-log4jproperties">6. Синтаксис файла log4j.properties</h2>

<p>В общем файле log4j.properties мы определяем следующие конфигурации:</p>

<ul>
  <li>Корневой логгер и его уровень. Мы также предоставляем имя для аппендера здесь.</li>
  <li>Затем мы назначаем действительный аппендер для определённого имени аппендера.</li>
  <li>Наконец, мы определяем макет, цель, уровень и т. д. для определённого аппендера.</li>
</ul>

<p>Давайте посмотрим на синтаксис общего файла log4j.properties:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Корневой логгер с именем аппендера
log4j.rootLogger = DEBUG, NAME

# Назначаем NAME действительный аппендер
log4j.appender.NAME = org.apache.log4j.FileAppender

# Определяем макет для NAME
log4j.appender.NAME.layout=org.apache.log4j.PatternLayout
log4j.appender.NAME.layout.conversionPattern=%m%n
</code></pre></div></div>

<p>Здесь NAME — это имя аппендера. Как уже обсуждалось ранее, мы можем прикрепить несколько аппендеров к логгеру, чтобы направлять логи в разные назначения.</p>

<h2 id="7-примеры">7. Примеры</h2>

<p>Теперь давайте разберём конфигурации файла log4j.properties для различных аппендеров с помощью нескольких примеров.</p>

<h3 id="71-пример-программы">7.1. Пример программы</h3>

<p>Давайте начнём с примерного приложения, которое логирует некоторые сообщения:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.apache.log4j.Logger</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Log4jExample</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Logger</span> <span class="n">logger</span> <span class="o">=</span> <span class="nc">Logger</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="nc">Log4jExample</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">2000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"This is the "</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">" time I say 'Hello World'."</span><span class="o">);</span>
            <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Приложение простое — оно записывает некоторые сообщения в цикле с короткой задержкой между итерациями. В нём 2,000 итераций, и в каждой итерации есть пауза в 100 мс. Таким образом, выполнение должно занять около трёх с половиной минут. Мы будем использовать это приложение в наших примерах ниже.</p>

<h3 id="72-логирование-в-консоль">7.2. Логирование в консоль</h3>

<p>Консоль является местом по умолчанию для логирования сообщений, если конфигурационный файл не найден. Давайте создадим конфигурацию log4j.properties для ConsoleAppender с корневым логгером и также определим уровень логирования для него:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Корневой логгер
log4j.rootLogger=INFO, stdout

# Направляем лог-сообщения в stdout
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target=System.out
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n
</code></pre></div></div>

<p>Здесь мы определили файл log4j.properties со следующими спецификациями:</p>

<ul>
  <li>Мы установили уровень корневого логгера как INFO. Это означает, что все лог-события с уровнем INFO и выше будут записываться. Мы также задали имя для аппендера как stdout.</li>
  <li>Поскольку мы хотим направить логи в консоль, мы назначили аппендер как org.apache.log4j.ConsoleAppender и цель как System.out.</li>
  <li>Наконец, мы указали формат для PatternLayout, в котором хотим выводить логи, используя ConversionPattern.</li>
</ul>

<p>Давайте также разберём значение каждого из символов преобразования в ConversionPattern, которые мы использовали:</p>

<ul>
  <li><strong>%d</strong> добавляет временную метку в заданном формате.</li>
  <li><strong>%-5p</strong> добавляет информацию об уровне логирования к каждому лог-сообщению. Это означает, что приоритет события логирования должен быть выровнен по левому краю с шириной в пять символов.</li>
  <li><strong>%c{1}</strong> выводит квалифицированное имя класса, опционально за которым следуют имена пакетов (квалификатор точности), то есть логирует конкретное лог-сообщение.</li>
  <li><strong>%L</strong> выводит номер строки конкретного лог-события.</li>
  <li><strong>%m</strong> выводит фактическое лог-сообщение.</li>
  <li><strong>%n</strong> добавляет новую строку после каждого лог-сообщения.</li>
</ul>

<p>Таким образом, когда мы запускаем наше примерное приложение, мы получаем следующие строки, напечатанные в консоли:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2023-08-01 00:27:25 INFO Log4jExample:15 - This is the 1 time I say 'Hello World'.
...
...
2023-08-01 00:27:25 INFO Log4jExample:15 - This is the 2000 time I say 'Hello World'.
</code></pre></div></div>

<p><a href="https://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/PatternLayout.html">Документация для класса PatternLayout</a> объясняет больше о символах преобразования, которые мы можем использовать в зависимости от наших нужд.</p>

<h3 id="73-несколько-назначений">7.3. Несколько назначений</h3>

<p>Как уже обсуждалось ранее, мы можем перенаправлять лог-события в несколько назначений:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Корневой логгер
log4j.rootLogger=INFO, file, stdout

# Перенаправление в файл
log4j.appender.file=org.apache.log4j.RollingFileAppender
log4j.appender.file.File=C:\\Baeldung\\app.log
log4j.appender.file.MaxFileSize=5KB
log4j.appender.file.MaxBackupIndex=2
log4j.appender.file.layout=org.apache.log4j.PatternLayout
log4j.appender.file.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n

# Перенаправление в консоль
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target=System.out
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n
</code></pre></div></div>

<p>Здесь мы использовали два аппендера, чтобы перенаправить лог-сообщения как в файл, так и в консоль. Также мы назначили RollingFileAppender для нашего файлового аппендера. Мы используем RollingFileAppender, когда знаем, что лог-файлы могут со временем увеличиваться в размере.</p>

<p>В нашем примере выше мы использовали RollingFileAppender, который прокручивает лог-файлы на основе как размера, так и количества лог-файлов, используя параметры MaxFileSize и MaxBackupIndex. Таким образом, лог-файл будет прокручиваться, когда его размер достигнет 5 КБ, и мы будем хранить максимум два прокрученных лог-файла в качестве резервной копии.</p>

<p>Когда мы запускаем наше приложение, мы получаем следующие файлы, содержащие те же лог-сообщения, что и в предыдущем примере:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>31/01/2024  10:28    138 app.log
31/01/2024  10:28  5.281 app.log.1
31/01/2024  10:28  5.281 app.log.2
</code></pre></div></div>

<h2 id="8-заключение">8. Заключение</h2>

<p>В этой статье мы рассмотрели Log4j и его три компонента — логгеры, аппендеры и макеты. Мы также поняли синтаксис файла log4j.properties и некоторые простые примеры конфигурации файла log4j.properties.</p>

<p><a href="https://www.baeldung.com/java-log4j-properties-guide">оригинал</a></p>]]></content><author><name>Ринат Мамбетов</name></author><category term="logging" /><summary type="html"><![CDATA[Log4J — это популярный фреймворк для логирования с открытым исходным кодом, написанный на Java. Log4j широко используется в различных приложениях на Java. Более того, он является потокобезопасным, быстрым и предоставляет иерархию именованных логгеров. Log4j распространяется под лицензией Apache Software License с открытым исходным кодом.]]></summary></entry><entry><title type="html">Тестирование со Spring Boot</title><link href="http://localhost:4000/springboot/2024/06/29/springboot-testing.html" rel="alternate" type="text/html" title="Тестирование со Spring Boot" /><published>2024-06-29T18:18:05+03:00</published><updated>2024-06-29T18:18:05+03:00</updated><id>http://localhost:4000/springboot/2024/06/29/springboot-testing</id><content type="html" xml:base="http://localhost:4000/springboot/2024/06/29/springboot-testing.html"><![CDATA[<p>В этом руководстве мы рассмотрим написание тестов с использованием встроенной поддержки фреймворка Spring Boot. Мы охватим модульные тесты, которые могут выполняться в изоляции, а также интеграционные тесты, которые будут загружать контекст Spring перед выполнением тестов.</p>

<h2 id="1-настройка-проекта">1. Настройка проекта</h2>
<p>Приложение, которое мы будем использовать в этой статье, представляет собой API, предоставляющее некоторые базовые операции с ресурсом “Employee”. Это типичная многослойная архитектура — вызов API обрабатывается от Контроллера к Сервису и далее к слою хранения данных.</p>

<h2 id="2-зависимости-maven">2. Зависимости Maven</h2>
<p>Сначала давайте добавим наши зависимости для тестирования:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>spring-boot-starter-test<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;scope&gt;</span>test<span class="nt">&lt;/scope&gt;</span>
    <span class="nt">&lt;version&gt;</span>3.3.4<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>com.h2database<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>h2<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;scope&gt;</span>test<span class="nt">&lt;/scope&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div>

<p>Зависимость spring-boot-starter-test является основной и содержит большинство элементов, необходимых для наших тестов.</p>

<p>База данных H2 — это наша база данных в памяти. Она устраняет необходимость в настройке и запуске реальной базы данных для тестирования.</p>

<h2 id="3-интеграционное-тестирование-с-springboottest">3. Интеграционное тестирование с @SpringBootTest</h2>

<p>Как следует из названия, интеграционные тесты сосредоточены на интеграции различных слоев приложения. Это также означает, что здесь не используется мокирование.</p>

<p>В идеале мы должны отделять интеграционные тесты от модульных и не запускать их вместе с модульными тестами. Мы можем сделать это, используя другой профиль, чтобы запускать только интеграционные тесты. Причины для этого могут быть следующими: интеграционные тесты требуют много времени и могут нуждаться в реальной базе данных для выполнения.</p>

<p>Однако в этой статье мы не будем на этом сосредотачиваться и вместо этого воспользуемся хранилищем данных H2 в памяти.</p>

<p>Интеграционные тесты требуют запуска контейнера для выполнения тестовых случаев. Поэтому для этого требуется дополнительная настройка — все это легко реализуется в Spring Boot:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RunWith</span><span class="o">(</span><span class="nc">SpringRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="nd">@SpringBootTest</span><span class="o">(</span>
  <span class="n">webEnvironment</span> <span class="o">=</span> <span class="nc">SpringBootTest</span><span class="o">.</span><span class="na">WebEnvironment</span><span class="o">.</span><span class="na">MOCK</span><span class="o">,</span>
  <span class="n">classes</span> <span class="o">=</span> <span class="nc">Application</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="nd">@AutoConfigureMockMvc</span>
<span class="nd">@TestPropertySource</span><span class="o">(</span>
  <span class="n">locations</span> <span class="o">=</span> <span class="s">"classpath:application-integrationtest.properties"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmployeeRestControllerIntegrationTest</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">MockMvc</span> <span class="n">mvc</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">EmployeeRepository</span> <span class="n">repository</span><span class="o">;</span>

    <span class="c1">// write test cases here</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Аннотация @SpringBootTest полезна, когда нам нужно загрузить весь контейнер. Эта аннотация работает, создавая ApplicationContext, который будет использоваться в наших тестах.</p>

<p>Мы можем использовать атрибут webEnvironment аннотации @SpringBootTest для настройки нашей рабочей среды; здесь мы используем WebEnvironment.MOCK, чтобы контейнер работал в имитированной среде сервлетов.</p>

<p>Далее, аннотация @TestPropertySource помогает настроить расположение файлов свойств, специфичных для наших тестов. Обратите внимание, что файл свойств, загруженный с помощью @TestPropertySource, будет переопределять существующий файл application.properties.</p>

<p>Файл application-integrationtest.properties содержит детали для настройки хранилища данных:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>spring.datasource.url = jdbc:h2:mem:test
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.H2Dialect
</code></pre></div></div>
<p>Если мы хотим запускать наши интеграционные тесты с использованием MySQL, мы можем изменить указанные выше значения в файле свойств.</p>

<p>Тестовые случаи для интеграционных тестов могут выглядеть аналогично модульным тестам слоя Контроллера:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">givenEmployees_whenGetEmployees_thenStatus200</span><span class="o">()</span>
  <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>

    <span class="n">createTestEmployee</span><span class="o">(</span><span class="s">"bob"</span><span class="o">);</span>

    <span class="n">mvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span><span class="n">get</span><span class="o">(</span><span class="s">"/api/employees"</span><span class="o">)</span>
      <span class="o">.</span><span class="na">contentType</span><span class="o">(</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">))</span>
      <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">status</span><span class="o">().</span><span class="na">isOk</span><span class="o">())</span>
      <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">content</span><span class="o">()</span>
      <span class="o">.</span><span class="na">contentTypeCompatibleWith</span><span class="o">(</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">))</span>
      <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">jsonPath</span><span class="o">(</span><span class="s">"$[0].name"</span><span class="o">,</span> <span class="n">is</span><span class="o">(</span><span class="s">"bob"</span><span class="o">)));</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Разница с модульными тестами слоя Контроллера заключается в том, что здесь ничего не мокируется, и будут выполняться сценарии от начала до конца.</p>

<h2 id="4-конфигурация-тестов-с-помощью-testconfiguration">4. Конфигурация тестов с помощью @TestConfiguration</h2>

<p>Как мы видели в предыдущем разделе, тест, аннотированный @SpringBootTest, загрузит полный контекст приложения, что означает, что мы можем использовать @Autowire для любого бина, который будет обнаружен с помощью сканирования компонентов в нашем тесте:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RunWith</span><span class="o">(</span><span class="nc">SpringRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="nd">@SpringBootTest</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmployeeServiceImplIntegrationTest</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">EmployeeService</span> <span class="n">employeeService</span><span class="o">;</span>

    <span class="c1">// class code ...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Однако мы можем захотеть избежать загрузки реального контекста приложения и использовать специальную конфигурацию для тестов. Мы можем достичь этого с помощью аннотации @TestConfiguration. Существует два способа использования этой аннотации. Либо на статическом внутреннем классе в том же тестовом классе, где мы хотим использовать @Autowire для бина:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RunWith</span><span class="o">(</span><span class="nc">SpringRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmployeeServiceImplIntegrationTest</span> <span class="o">{</span>

    <span class="nd">@TestConfiguration</span>
    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">EmployeeServiceImplTestContextConfiguration</span> <span class="o">{</span>
        <span class="nd">@Bean</span>
        <span class="kd">public</span> <span class="nc">EmployeeService</span> <span class="nf">employeeService</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">EmployeeService</span><span class="o">()</span> <span class="o">{</span>
                <span class="c1">// implement methods</span>
            <span class="o">};</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">EmployeeService</span> <span class="n">employeeService</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>В качестве альтернативы мы можем создать отдельный класс конфигурации для тестов:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@TestConfiguration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmployeeServiceImplTestContextConfiguration</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">EmployeeService</span> <span class="nf">employeeService</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">EmployeeService</span><span class="o">()</span> <span class="o">{</span>
            <span class="c1">// implement methods</span>
        <span class="o">};</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Классы конфигурации, аннотированные @TestConfiguration, исключаются из сканирования компонентов, поэтому нам нужно явно импортировать их в каждом тесте, где мы хотим использовать @Autowire. Мы можем сделать это с помощью аннотации @Import:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RunWith</span><span class="o">(</span><span class="nc">SpringRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="nd">@Import</span><span class="o">(</span><span class="nc">EmployeeServiceImplTestContextConfiguration</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmployeeServiceImplIntegrationTest</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">EmployeeService</span> <span class="n">employeeService</span><span class="o">;</span>

    <span class="c1">// remaining class code</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="5-мокирование-с-помощью-mockbean">5. Мокирование с помощью @MockBean</h2>

<p>Наш код слоя Сервиса зависит от нашего Репозитория:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmployeeServiceImpl</span> <span class="kd">implements</span> <span class="nc">EmployeeService</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">EmployeeRepository</span> <span class="n">employeeRepository</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Employee</span> <span class="nf">getEmployeeByName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">employeeRepository</span><span class="o">.</span><span class="na">findByName</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Однако, чтобы протестировать слой Сервиса, нам не нужно знать или беспокоиться о том, как реализован слой Хранения данных. В идеале мы должны иметь возможность писать и тестировать наш код слоя Сервиса без подключения полного слоя Хранения данных.</p>

<p>Для достижения этой цели мы можем использовать поддержку мокирования, предоставляемую Spring Boot Test.</p>

<p>Давайте сначала взглянем на скелет тестового класса:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RunWith</span><span class="o">(</span><span class="nc">SpringRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmployeeServiceImplIntegrationTest</span> <span class="o">{</span>

    <span class="nd">@TestConfiguration</span>
    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">EmployeeServiceImplTestContextConfiguration</span> <span class="o">{</span>

        <span class="nd">@Bean</span>
        <span class="kd">public</span> <span class="nc">EmployeeService</span> <span class="nf">employeeService</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">EmployeeServiceImpl</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">EmployeeService</span> <span class="n">employeeService</span><span class="o">;</span>

    <span class="nd">@MockBean</span>
    <span class="kd">private</span> <span class="nc">EmployeeRepository</span> <span class="n">employeeRepository</span><span class="o">;</span>

    <span class="c1">// write test cases here</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Чтобы проверить класс Сервиса, нам нужно создать экземпляр класса Сервиса и сделать его доступным как @Bean, чтобы мы могли использовать @Autowire в нашем тестовом классе. Мы можем достичь этой конфигурации с помощью аннотации @TestConfiguration.</p>

<p>Еще один интересный момент здесь — это использование @MockBean. Она создает мок для EmployeeRepository, который можно использовать для обхода вызова к реальному EmployeeRepository:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Before</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setUp</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">Employee</span> <span class="n">alex</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Employee</span><span class="o">(</span><span class="s">"alex"</span><span class="o">);</span>

    <span class="nc">Mockito</span><span class="o">.</span><span class="na">when</span><span class="o">(</span><span class="n">employeeRepository</span><span class="o">.</span><span class="na">findByName</span><span class="o">(</span><span class="n">alex</span><span class="o">.</span><span class="na">getName</span><span class="o">()))</span>
      <span class="o">.</span><span class="na">thenReturn</span><span class="o">(</span><span class="n">alex</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Поскольку настройка завершена, тестовый случай будет проще:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">whenValidName_thenEmployeeShouldBeFound</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"alex"</span><span class="o">;</span>
    <span class="nc">Employee</span> <span class="n">found</span> <span class="o">=</span> <span class="n">employeeService</span><span class="o">.</span><span class="na">getEmployeeByName</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>

     <span class="n">assertThat</span><span class="o">(</span><span class="n">found</span><span class="o">.</span><span class="na">getName</span><span class="o">())</span>
      <span class="o">.</span><span class="na">isEqualTo</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
 <span class="o">}</span>
</code></pre></div></div>

<h2 id="6-интеграционное-тестирование-с-помощью-datajpatest">6. Интеграционное тестирование с помощью @DataJpaTest</h2>

<p>Мы будем работать с сущностью под названием Employee (Сотрудник), которая имеет свойства id (идентификатор) и name (имя).</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"person"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Employee</span> <span class="o">{</span>

    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">GenerationType</span><span class="o">.</span><span class="na">AUTO</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@Size</span><span class="o">(</span><span class="n">min</span> <span class="o">=</span> <span class="mi">3</span><span class="o">,</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">20</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="c1">// standard getters and setters, constructors</span>
<span class="o">}</span>
</code></pre></div></div>

<p>А вот и наш репозиторий, использующий Spring Data JPA:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Repository</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">EmployeeRepository</span> <span class="kd">extends</span> <span class="nc">JpaRepository</span><span class="o">&lt;</span><span class="nc">Employee</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nc">Employee</span> <span class="nf">findByName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">);</span>

<span class="o">}</span>
</code></pre></div></div>

<p>На этом код для слоя Хранения данных завершен. Теперь давайте перейдем к написанию нашего тестового класса.</p>

<p>Сначала создадим каркас нашего тестового класса:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RunWith</span><span class="o">(</span><span class="nc">SpringRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="nd">@DataJpaTest</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmployeeRepositoryIntegrationTest</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">TestEntityManager</span> <span class="n">entityManager</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">EmployeeRepository</span> <span class="n">employeeRepository</span><span class="o">;</span>

    <span class="c1">// write test cases here</span>

<span class="o">}</span>
</code></pre></div></div>

<p>@RunWith(SpringRunner.class) обеспечивает связь между возможностями тестирования Spring Boot и JUnit. Каждый раз, когда мы используем какие-либо функции тестирования Spring Boot в наших тестах JUnit, эта аннотация будет необходима.</p>

<p>@DataJpaTest предоставляет стандартную настройку, необходимую для тестирования слоя Хранения данных:</p>

<ul>
  <li>конфигурация H2, базы данных в памяти</li>
  <li>настройка Hibernate, Spring Data и DataSource</li>
  <li>выполнение @EntityScan</li>
  <li>включение логирования SQL</li>
</ul>

<p>Чтобы выполнить операции с базой данных, нам нужны некоторые записи, уже находящиеся в нашей базе данных. Для настройки этих данных мы можем использовать TestEntityManager.</p>

<p>TestEntityManager в Spring Boot является альтернативой стандартному JPA EntityManager и предоставляет методы, которые обычно используются при написании тестов.</p>

<p>EmployeeRepository — это компонент, который мы собираемся тестировать.</p>

<p>Теперь давайте напишем наш первый тестовый случай:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">whenFindByName_thenReturnEmployee</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// given</span>
    <span class="nc">Employee</span> <span class="n">alex</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Employee</span><span class="o">(</span><span class="s">"alex"</span><span class="o">);</span>
    <span class="n">entityManager</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">alex</span><span class="o">);</span>
    <span class="n">entityManager</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>

    <span class="c1">// when</span>
    <span class="nc">Employee</span> <span class="n">found</span> <span class="o">=</span> <span class="n">employeeRepository</span><span class="o">.</span><span class="na">findByName</span><span class="o">(</span><span class="n">alex</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>

    <span class="c1">// then</span>
    <span class="n">assertThat</span><span class="o">(</span><span class="n">found</span><span class="o">.</span><span class="na">getName</span><span class="o">())</span>
      <span class="o">.</span><span class="na">isEqualTo</span><span class="o">(</span><span class="n">alex</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>

<p>В приведенном выше тесте мы используем TestEntityManager для вставки записи Employee в базу данных и считываем ее с помощью API поиска по имени.</p>

<p>Часть assertThat(…) принадлежит библиотеке Assertj, которая поставляется в комплекте со Spring Boot.</p>

<h2 id="7-модульное-тестирование-с-помощью-webmvctest">7. Модульное тестирование с помощью @WebMvcTest</h2>

<p>Наш контроллер зависит от слоя Сервиса; давайте включим только один метод для простоты:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RestController</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/api"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmployeeRestController</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">EmployeeService</span> <span class="n">employeeService</span><span class="o">;</span>

    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"/employees"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Employee</span><span class="o">&gt;</span> <span class="nf">getAllEmployees</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">employeeService</span><span class="o">.</span><span class="na">getAllEmployees</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Поскольку мы сосредоточены только на коде контроллера, естественно, что мы будем использовать мокирование кода слоя Сервиса для наших модульных тестов:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RunWith</span><span class="o">(</span><span class="nc">SpringRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="nd">@WebMvcTest</span><span class="o">(</span><span class="nc">EmployeeRestController</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmployeeRestControllerIntegrationTest</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">MockMvc</span> <span class="n">mvc</span><span class="o">;</span>

    <span class="nd">@MockBean</span>
    <span class="kd">private</span> <span class="nc">EmployeeService</span> <span class="n">service</span><span class="o">;</span>

    <span class="c1">// write test cases here</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Для тестирования контроллеров мы можем использовать @WebMvcTest. Он автоматически настраивает инфраструктуру Spring MVC для наших модульных тестов.</p>

<p>В большинстве случаев @WebMvcTest будет ограничен инициализацией одного контроллера. Мы также можем использовать его вместе с @MockBean, чтобы предоставить мокированные реализации для любых необходимых зависимостей.</p>

<p>@WebMvcTest также автоматически настраивает MockMvc, который предлагает мощный способ простого тестирования MVC контроллеров без запуска полного HTTP-сервера.</p>

<p>Сказав это, давайте напишем наш тестовый случай:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">givenEmployees_whenGetEmployees_thenReturnJsonArray</span><span class="o">()</span>
  <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>

    <span class="nc">Employee</span> <span class="n">alex</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Employee</span><span class="o">(</span><span class="s">"alex"</span><span class="o">);</span>

    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Employee</span><span class="o">&gt;</span> <span class="n">allEmployees</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">alex</span><span class="o">);</span>

    <span class="n">given</span><span class="o">(</span><span class="n">service</span><span class="o">.</span><span class="na">getAllEmployees</span><span class="o">()).</span><span class="na">willReturn</span><span class="o">(</span><span class="n">allEmployees</span><span class="o">);</span>

    <span class="n">mvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span><span class="n">get</span><span class="o">(</span><span class="s">"/api/employees"</span><span class="o">)</span>
      <span class="o">.</span><span class="na">contentType</span><span class="o">(</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">))</span>
      <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">status</span><span class="o">().</span><span class="na">isOk</span><span class="o">())</span>
      <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">jsonPath</span><span class="o">(</span><span class="s">"$"</span><span class="o">,</span> <span class="n">hasSize</span><span class="o">(</span><span class="mi">1</span><span class="o">)))</span>
      <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">jsonPath</span><span class="o">(</span><span class="s">"$[0].name"</span><span class="o">,</span> <span class="n">is</span><span class="o">(</span><span class="n">alex</span><span class="o">.</span><span class="na">getName</span><span class="o">())));</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Вызов метода get(…) можно заменить другими методами, соответствующими HTTP-методам, таким как put(), post() и т. д. Обратите внимание, что мы также устанавливаем тип содержимого в запросе.</p>

<p>MockMvc является гибким, и мы можем создавать любые запросы с его помощью.</p>

<h2 id="8-автоматически-настраиваемые-тесты">8. Автоматически настраиваемые тесты</h2>

<p>Одной из удивительных особенностей автоматической настройки аннотаций Spring Boot является то, что они помогают загружать части полного приложения и тестировать специфические слои кодовой базы.</p>

<p>В дополнение к вышеупомянутым аннотациям, вот список нескольких широко используемых аннотаций:</p>

<ul>
  <li><strong>@WebFluxTest</strong>: Мы можем использовать аннотацию @WebFluxTest для тестирования контроллеров Spring WebFlux. Она часто используется вместе с @MockBean для предоставления мокированных реализаций необходимых зависимостей.</li>
  <li><strong>@JdbcTest</strong>: Мы можем использовать аннотацию @JdbcTest для тестирования JPA приложений, но она предназначена для тестов, которые требуют только DataSource. Аннотация настраивает встроенную базу данных в памяти и JdbcTemplate.</li>
  <li><strong>@JooqTest</strong>: Для тестирования, связанного с jOOQ, мы можем использовать аннотацию @JooqTest, которая настраивает DSLContext.</li>
  <li><strong>@DataMongoTest</strong>: Для тестирования приложений MongoDB полезна аннотация @DataMongoTest. По умолчанию она настраивает встроенную базу данных MongoDB в памяти, если драйвер доступен через зависимости, настраивает MongoTemplate, сканирует классы с аннотацией @Document и настраивает репозитории Spring Data MongoDB.</li>
  <li><strong>@DataRedisTest</strong>: Упрощает тестирование приложений Redis. Она сканирует классы с аннотацией @RedisHash и по умолчанию настраивает репозитории Spring Data Redis.</li>
  <li><strong>@DataLdapTest</strong>: Настраивает встроенный LDAP в памяти (если доступен), настраивает LdapTemplate, сканирует классы с аннотацией @Entry и по умолчанию настраивает репозитории Spring Data LDAP.</li>
  <li><strong>@RestClientTest</strong>: Обычно мы используем аннотацию @RestClientTest для тестирования REST-клиентов. Она автоматически настраивает различные зависимости, такие как поддержка Jackson, GSON и Jsonb; настраивает RestTemplateBuilder и по умолчанию добавляет поддержку MockRestServiceServer.</li>
  <li><strong>@JsonTest</strong>: Инициализирует контекст приложения Spring только с теми бинами, которые необходимы для тестирования сериализации JSON.</li>
</ul>

<p><a href="https://www.baeldung.com/spring-boot-testing">оригинал</a></p>]]></content><author><name>Ринат Мамбетов</name></author><category term="springboot" /><summary type="html"><![CDATA[В этом руководстве мы рассмотрим написание тестов с использованием встроенной поддержки фреймворка Spring Boot. Мы охватим модульные тесты, которые могут выполняться в изоляции, а также интеграционные тесты, которые будут загружать контекст Spring перед выполнением тестов.]]></summary></entry><entry><title type="html">Руководство по Java 8 Stream API</title><link href="http://localhost:4000/java/2024/06/21/java-stream.html" rel="alternate" type="text/html" title="Руководство по Java 8 Stream API" /><published>2024-06-21T18:18:05+03:00</published><updated>2024-06-21T18:18:05+03:00</updated><id>http://localhost:4000/java/2024/06/21/java-stream</id><content type="html" xml:base="http://localhost:4000/java/2024/06/21/java-stream.html"><![CDATA[<p>В этом руководстве рассматривается практическое использование Java 8 Streams от создания до параллельного выполнения.</p>

<p>Чтобы понять этот материал, читателям необходимо иметь базовые знания о Java 8 (лямбда-выражения, Optional, ссылки на методы).</p>

<h2 id="1-создание-потока">1. Создание потока</h2>

<p>В Java существует множество способов создания экземпляра потока из различных источников данных.</p>

<p>После создания экземпляра потока, он не изменяет исходный источник данных. Это означает, что любые операции, выполняемые над потоком (например, фильтрация, маппинг, сортировка), не влияют на сам исходный набор данных. Это обеспечивает безопасность данных и предотвращает нежелательные побочные эффекты.</p>

<p>Благодаря тому, что потоки не модифицируют исходные данные, из одного и того же источника можно создать несколько потоков. Это позволяет одновременно выполнять различные операции обработки данных над одним и тем же набором данных без изменения исходных данных.</p>

<h3 id="11-пустой-поток">1.1. Пустой поток</h3>

<p>Мы должны использовать метод <code class="language-plaintext highlighter-rouge">empty()</code> для создания пустого потока:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">streamEmpty</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">empty</span><span class="o">();</span>
</code></pre></div></div>

<p>Мы часто используем метод <code class="language-plaintext highlighter-rouge">empty()</code> при создании, чтобы избежать возврата null для потоков без элементов:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">streamOf</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">list</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">list</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">?</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">empty</span><span class="o">()</span> <span class="o">:</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="12-поток-коллекции">1.2. Поток коллекции</h3>

<p>Мы также можем создать поток из любого типа коллекции:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Collection</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">collection</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">);</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">streamOfCollection</span> <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="na">stream</span><span class="o">();</span>
</code></pre></div></div>

<h3 id="13-поток-массива">1.3. Поток массива</h3>

<p>Массив также может быть источником потока:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">streamOfArray</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">);</span>
</code></pre></div></div>

<p>Мы также можем создать Stream из существующего массива или части массива:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[]{</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">};</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">streamOfArrayFull</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">arr</span><span class="o">);</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">streamOfArrayPart</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span> <span class="c1">// "b" "c"</span>
</code></pre></div></div>

<h3 id="14-streambuilder">1.4. Stream.builder()</h3>

<p>Желаемый тип должен быть дополнительно указан в правой части инструкции, когда используется Builder, в противном случае метод <code class="language-plaintext highlighter-rouge">build()</code> создаст экземпляр <code class="language-plaintext highlighter-rouge">Stream&lt;Object&gt;</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">streamBuilder</span> <span class="o">=</span>
  <span class="nc">Stream</span><span class="o">.&lt;</span><span class="nc">String</span><span class="o">&gt;</span><span class="n">builder</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="s">"a"</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="s">"b"</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="s">"c"</span><span class="o">).</span><span class="na">build</span><span class="o">();</span>
</code></pre></div></div>

<h3 id="15-streamgenerate">1.5. Stream.generate()</h3>

<p>Метод <code class="language-plaintext highlighter-rouge">generate()</code> принимает <code class="language-plaintext highlighter-rouge">Supplier&lt;T&gt;</code> для генерации элемента. Поскольку результирующий поток бесконечен, разработчик должен указать желаемый размер, иначе метод generate() будет работать до тех пор, пока не достигнет предела памяти:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">streamGenerated</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">generate</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="s">"element"</span><span class="o">).</span><span class="na">limit</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
</code></pre></div></div>

<p>Приведенный выше код создает последовательность из десяти строк со значением “element”.</p>

<h3 id="16-streamiterate">1.6. Stream.iterate()</h3>

<p>Другой способ создания бесконечного потока - это использование метода <code class="language-plaintext highlighter-rouge">iterate()</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">streamIterated</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">iterate</span><span class="o">(</span><span class="mi">40</span><span class="o">,</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="o">).</span><span class="na">limit</span><span class="o">(</span><span class="mi">20</span><span class="o">);</span>
</code></pre></div></div>

<p>Первый элемент результирующего stream является первым параметром метода <code class="language-plaintext highlighter-rouge">iterate()</code>. При создании каждого следующего элемента указанная функция применяется к предыдущему элементу. В приведенном выше примере вторым элементом будет 42.</p>

<h3 id="17-поток-примитивов">1.7. Поток примитивов</h3>

<p>Java 8 предлагает возможность создавать потоки из трех примитивных типов: int, long и double. Поскольку <code class="language-plaintext highlighter-rouge">Stream&lt;T&gt;</code> является универсальным интерфейсом, и нет способа использовать примитивы в качестве параметра типа с generics, были созданы три новых специальных интерфейса: IntStream, LongStream, DoubleStream.</p>

<p>Использование новых интерфейсов устраняет ненужную автоматическую упауовку, что позволяет повысить производительность:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IntStream</span> <span class="n">intStream</span> <span class="o">=</span> <span class="nc">IntStream</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
<span class="nc">LongStream</span> <span class="n">longStream</span> <span class="o">=</span> <span class="nc">LongStream</span><span class="o">.</span><span class="na">rangeClosed</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
</code></pre></div></div>

<p>Метод <code class="language-plaintext highlighter-rouge">range(int startInclusive, int endExclusive)</code> создает упорядоченный поток от первого параметра ко второму параметру. Оно увеличивает значение последующих элементов с шагом, равным 1. Результат не включает последний параметр, это просто верхняя граница последовательности.</p>

<p>Метод <code class="language-plaintext highlighter-rouge">rangeClosed(int startInclusive, int endInclusive)</code>  выполняет то же самое, только с одним отличием, включен второй элемент. Мы можем использовать эти два метода для генерации любого из трех типов потоков примитивов.</p>

<p>Начиная с Java 8, класс Random предоставляет широкий спектр методов для генерации потоков примитивов. Например, следующий код создает DoubleStream, который состоит из трех элементов:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Random</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>
<span class="nc">DoubleStream</span> <span class="n">doubleStream</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="na">doubles</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="18-поток-строк">1.8. Поток строк</h3>

<p>Мы также можем использовать String в качестве источника для создания потока с помощью метода <code class="language-plaintext highlighter-rouge">chars()</code> класса String. Поскольку в JDK нет интерфейса для CharStream, мы используем IntStream вместо этого для представления потока символов.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IntStream</span> <span class="n">streamOfChars</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">.</span><span class="na">chars</span><span class="o">();</span>
</code></pre></div></div>

<p>Следующий пример разбивает строку на подстроки в соответствии с указанным регулярным выражением:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">streamOfString</span> <span class="o">=</span>
  <span class="nc">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">", "</span><span class="o">).</span><span class="na">splitAsStream</span><span class="o">(</span><span class="s">"a, b, c"</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="19-поток-файлов">1.9. Поток файлов</h3>

<p>Кроме того, Java NIO класс Files позволяет нам генерировать <code class="language-plaintext highlighter-rouge">Stream&lt;String&gt;</code> текстового файла с помощью метода <code class="language-plaintext highlighter-rouge">lines()</code>. Каждая строка текста становится элементом потока:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Path</span> <span class="n">path</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"C:\\file.txt"</span><span class="o">);</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">streamOfStrings</span> <span class="o">=</span> <span class="nc">Files</span><span class="o">.</span><span class="na">lines</span><span class="o">(</span><span class="n">path</span><span class="o">);</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">streamWithCharset</span> <span class="o">=</span>
  <span class="nc">Files</span><span class="o">.</span><span class="na">lines</span><span class="o">(</span><span class="n">path</span><span class="o">,</span> <span class="nc">Charset</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"UTF-8"</span><span class="o">));</span>
</code></pre></div></div>

<p>Кодировка может быть указана в качестве аргумента метода <code class="language-plaintext highlighter-rouge">lines()</code>.</p>

<h2 id="2-ссылка-на-поток">2. Ссылка на поток</h2>

<p>Мы можем создать экземпляр потока и иметь доступную ссылку на него, если вызываются только промежуточные операции. Выполнение терминальной операции делает поток недоступным.</p>

<p>Чтобы продемонстрировать это, мы ненадолго забудем, что наилучшей практикой является объединение последовательности операций в цепочку. Помимо ненужной многословности, технически следующий код допустим:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stream</span> <span class="o">=</span>
  <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">).</span><span class="na">filter</span><span class="o">(</span><span class="n">element</span> <span class="o">-&gt;</span> <span class="n">element</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">"b"</span><span class="o">));</span>
<span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">anyElement</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="na">findAny</span><span class="o">();</span>
</code></pre></div></div>

<p>Однако попытка повторно использовать ту же ссылку после вызова операции терминала вызовет исключение IllegalStateException:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">firstElement</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="na">findFirst</span><span class="o">();</span>
</code></pre></div></div>

<p>Поскольку исключение IllegalStateException является исключением RuntimeException, компилятор не будет сигнализировать о проблеме. Поэтому очень важно помнить, что потоки Java 8 нельзя использовать повторно.</p>

<p>Такое поведение логично. Мы создали Stream для применения конечной последовательности операций к источнику элементов в функциональном стиле, а не для хранения элементов.</p>

<p>Итак, чтобы предыдущий код работал должным образом, необходимо внести некоторые изменения:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">elements</span> <span class="o">=</span>
  <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">).</span><span class="na">filter</span><span class="o">(</span><span class="n">element</span> <span class="o">-&gt;</span> <span class="n">element</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">"b"</span><span class="o">))</span>
    <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
<span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">anyElement</span> <span class="o">=</span> <span class="n">elements</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">findAny</span><span class="o">();</span>
<span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">firstElement</span> <span class="o">=</span> <span class="n">elements</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">findFirst</span><span class="o">();</span>
</code></pre></div></div>

<h2 id="3-потоковый-конвейер">3. Потоковый конвейер</h2>

<p>Для выполнения последовательности операций над элементами источника данных и агрегирования их результатов нам понадобятся три части: исходный код, промежуточные операции и терминальная операция.</p>

<p>Промежуточные операции возвращают новый измененный поток. Например, чтобы создать новый поток вместо существующего без нескольких элементов, следует использовать метод <code class="language-plaintext highlighter-rouge">skip()</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">onceModifiedStream</span> <span class="o">=</span>
  <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"abcd"</span><span class="o">,</span> <span class="s">"bbcd"</span><span class="o">,</span> <span class="s">"cbcd"</span><span class="o">).</span><span class="na">skip</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
</code></pre></div></div>

<p>Если нам нужно больше одной модификации, мы можем связать промежуточные операции. Давайте предположим, что нам также нужно заменить каждый элемент текущего <code class="language-plaintext highlighter-rouge">Stream&lt;String&gt;</code> подстрокой из первых нескольких символов. Мы можем сделать это, объединив методы <code class="language-plaintext highlighter-rouge">skip()</code> и <code class="language-plaintext highlighter-rouge">map()</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">twiceModifiedStream</span> <span class="o">=</span>
  <span class="n">stream</span><span class="o">.</span><span class="na">skip</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">map</span><span class="o">(</span><span class="n">element</span> <span class="o">-&gt;</span> <span class="n">element</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">));</span>
</code></pre></div></div>

<p>Поток сам по себе ничего не стоит; пользователя интересует результат операции терминала, который может быть значением некоторого типа или действием, применяемым к каждому элементу потока. Мы можем использовать только одну терминальную операцию для каждого потока.</p>

<p>Правильный и наиболее удобный способ использования потоков - это конвейер потока, который представляет собой цепочку из источника потока, промежуточных операций и терминальной операции:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"abc1"</span><span class="o">,</span> <span class="s">"abc2"</span><span class="o">,</span> <span class="s">"abc3"</span><span class="o">);</span>
<span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">skip</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
  <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">element</span> <span class="o">-&gt;</span> <span class="n">element</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">)).</span><span class="na">sorted</span><span class="o">().</span><span class="na">count</span><span class="o">();</span>
</code></pre></div></div>

<h2 id="4-отложенный-вызов">4. Отложенный вызов</h2>

<p>Промежуточные операции являются ленивыми. Это означает, что они будут вызываться только в том случае, если это необходимо для выполнения терминальной операции.</p>

<p>Например, давайте вызовем метод <code class="language-plaintext highlighter-rouge">wasCalled()</code>, который увеличивает внутренний счетчик при каждом вызове:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">long</span> <span class="n">counter</span><span class="o">;</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">wasCalled</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">counter</span><span class="o">++;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Теперь давайте вызовем метод <code class="language-plaintext highlighter-rouge">wasCalled()</code> из операции <code class="language-plaintext highlighter-rouge">filter()</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"abc1"</span><span class="o">,</span> <span class="s">"abc2"</span><span class="o">,</span> <span class="s">"abc3"</span><span class="o">);</span>
<span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">filter</span><span class="o">(</span><span class="n">element</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="n">wasCalled</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">element</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">"2"</span><span class="o">);</span>
<span class="o">});</span>
</code></pre></div></div>

<p>Поскольку у нас есть источник из трех элементов, мы можем предположить, что метод <code class="language-plaintext highlighter-rouge">filter()</code> будет вызван три раза, а значение переменной counter будет равно 3. Однако выполнение этого кода вообще не изменяет счетчик , он по-прежнему равен нулю, поэтому метод <code class="language-plaintext highlighter-rouge">filter()</code> даже не был вызван ни разу. Причина, это отсутствие терминальной операции.</p>

<p>Давайте немного перепишем этот код, добавив операцию <code class="language-plaintext highlighter-rouge">map()</code> и терминальную операцию, <code class="language-plaintext highlighter-rouge">findFirst()</code>. Мы также добавим возможность отслеживать порядок вызовов методов с помощью ведения журнала:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">filter</span><span class="o">(</span><span class="n">element</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"filter() was called"</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">element</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">"2"</span><span class="o">);</span>
<span class="o">}).</span><span class="na">map</span><span class="o">(</span><span class="n">element</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"map() was called"</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">element</span><span class="o">.</span><span class="na">toUpperCase</span><span class="o">();</span>
<span class="o">}).</span><span class="na">findFirst</span><span class="o">();</span>
</code></pre></div></div>

<p>Результирующий журнал показывает, что мы дважды вызывали метод <code class="language-plaintext highlighter-rouge">filter()</code> и один раз метод <code class="language-plaintext highlighter-rouge">map()</code>. Это потому, что конвейер выполняется вертикально. В нашем примере первый элемент stream не удовлетворял предикату filter. Затем мы вызвали метод <code class="language-plaintext highlighter-rouge">filter()</code> для второго элемента, который прошел фильтр. Не вызывая <code class="language-plaintext highlighter-rouge">filter()</code> для третьего элемента, мы перешли по конвейеру к методу <code class="language-plaintext highlighter-rouge">map()</code>.</p>

<p>Операция <code class="language-plaintext highlighter-rouge">findFirst()</code> удовлетворяет только одному элементу. Итак, в этом конкретном примере отложенный вызов позволил нам избежать двух вызовов метода, одного для <code class="language-plaintext highlighter-rouge">filter()</code> (для третьего элемента) и одного для <code class="language-plaintext highlighter-rouge">map()</code> (для первого элемента).</p>

<h2 id="5-порядок-выполнения">5. Порядок выполнения</h2>

<p>С точки зрения производительности, правильный порядок является одним из наиболее важных аспектов операций объединения в цепочку в конвейере stream:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">map</span><span class="o">(</span><span class="n">element</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="n">wasCalled</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">element</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
<span class="o">}).</span><span class="na">skip</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="na">count</span><span class="o">();</span>
</code></pre></div></div>

<p>Выполнение этого кода увеличит значение счетчика на три. Это означает, что мы вызвали метод stream три раза, но значение size равно единице. Итак, результирующий поток содержит только один элемент, и мы выполнили дорогостоящие операции map() без причины два раза из трех.</p>

<p>Если мы изменим порядок методов skip() и map(), то счетчик увеличится всего на единицу. Итак, мы вызовем метод <code class="language-plaintext highlighter-rouge">map()</code> только один раз:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">skip</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="na">map</span><span class="o">(</span><span class="n">element</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="n">wasCalled</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">element</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
<span class="o">}).</span><span class="na">count</span><span class="o">();</span>
</code></pre></div></div>

<p>Это подводит нас к следующему правилу: промежуточные операции, которые уменьшают размер потока, должны быть размещены перед операциями, которые применяются к каждому элементу. Итак, нам нужно сохранить такие методы, как <code class="language-plaintext highlighter-rouge">skip()</code>, <code class="language-plaintext highlighter-rouge">filter()</code>, и <code class="language-plaintext highlighter-rouge">distinct()</code> в верхней части нашего конвейера stream.</p>

<h2 id="6-сокращение-потока">6. Сокращение потока</h2>

<p>API имеет множество терминальных операций, которые сводят поток к типу или примитиву: <code class="language-plaintext highlighter-rouge">count()</code>, <code class="language-plaintext highlighter-rouge">max()</code>, <code class="language-plaintext highlighter-rouge">min()</code>, и <code class="language-plaintext highlighter-rouge">sum()</code>. Однако эти операции работают в соответствии с предопределенной реализацией. Ну и что, если разработчику необходимо настроить механизм сокращения потока? Есть два метода, которые позволяют нам сделать это, методы <code class="language-plaintext highlighter-rouge">reduce()</code> и <code class="language-plaintext highlighter-rouge">collect()</code>.</p>

<h3 id="61-метод-reduce-объединение">6.1. Метод reduce() (объединение)</h3>

<p>Существует три варианта этого метода, которые отличаются своими сигнатурами и типами возвращаемых данных. Они могут иметь следующие параметры:</p>

<p>identity – начальное значение для накопителя или значение по умолчанию, если поток пуст и накапливать нечего</p>

<p>accumulator – функция, которая определяет логику агрегирования элементов. Поскольку accumulator создает новое значение для каждого шага объединения, количество новых значений равно размеру потока, и полезно только последнее значение. Это не очень хорошо сказывается на производительности.</p>

<p>combiner – функция, которая агрегирует результаты сумматора. Мы вызываем combiner только в параллельном режиме, чтобы объединить результаты accumulators из разных потоков.</p>

<p>Теперь давайте посмотрим на эти три метода в действии:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">OptionalInt</span> <span class="n">reduced</span> <span class="o">=</span>
  <span class="nc">IntStream</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">).</span><span class="na">reduce</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">);</span> <span class="c1">// 6 (1 + 2 + 3)</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">reducedTwoParams</span> <span class="o">=</span>
  <span class="nc">IntStream</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">).</span><span class="na">reduce</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">);</span> <span class="c1">// 16 (10 + 1 + 2 + 3)</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">reducedParams</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
  <span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
     <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"combiner was called"</span><span class="o">);</span>
     <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span>
  <span class="o">});</span>
</code></pre></div></div>

<p>Результат будет таким же, как в предыдущем примере (16), и логирования не будет, что означает, что combiner не вызывался. Чтобы combiner работал, поток должен быть параллельным:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">reducedParallel</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="na">parallelStream</span><span class="o">()</span>
    <span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
       <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"combiner was called"</span><span class="o">);</span>
       <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span>
    <span class="o">});</span>
</code></pre></div></div>

<p>Результат здесь другой (36), и combiner вызывался дважды. Здесь объединение выполняется по следующему алгоритму: накопитель запускается три раза путем добавления каждого элемента потока к identity. Эти действия выполняются параллельно. В результате у них получилось (10 + 1 = 11; 10 + 2 = 12; 10 + 3 = 13;). Теперь combiner может объединить эти три результата. Для этого требуется две итерации (12 + 13 = 25; 25 + 11 = 36).</p>

<h3 id="62-метод-collect">6.2. Метод collect()</h3>

<p>Объединение потока также может быть выполнено с помощью другой терминальной операции, метода <code class="language-plaintext highlighter-rouge">collect()</code>. Он принимает аргумент типа Collector, который определяет механизм объединения. Для большинства распространенных операций уже созданы предопределенные коллекторы. К ним можно получить доступ с помощью типа Collectors.</p>

<p>В этом разделе мы будем использовать следующий список в качестве источника для всех потоков:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">productList</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="k">new</span> <span class="nc">Product</span><span class="o">(</span><span class="mi">23</span><span class="o">,</span> <span class="s">"potatoes"</span><span class="o">),</span>
  <span class="k">new</span> <span class="nf">Product</span><span class="o">(</span><span class="mi">14</span><span class="o">,</span> <span class="s">"orange"</span><span class="o">),</span> <span class="k">new</span> <span class="nc">Product</span><span class="o">(</span><span class="mi">13</span><span class="o">,</span> <span class="s">"lemon"</span><span class="o">),</span>
  <span class="k">new</span> <span class="nf">Product</span><span class="o">(</span><span class="mi">23</span><span class="o">,</span> <span class="s">"bread"</span><span class="o">),</span> <span class="k">new</span> <span class="nc">Product</span><span class="o">(</span><span class="mi">13</span><span class="o">,</span> <span class="s">"sugar"</span><span class="o">));</span>
</code></pre></div></div>

<p>Преобразование потока в коллекцию (Collection, List или Set):</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">collectorCollection</span> <span class="o">=</span>
  <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">map</span><span class="o">(</span><span class="nl">Product:</span><span class="o">:</span><span class="n">getName</span><span class="o">).</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</code></pre></div></div>

<p>Объединение в строку:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">listToString</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">map</span><span class="o">(</span><span class="nl">Product:</span><span class="o">:</span><span class="n">getName</span><span class="o">)</span>
  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">joining</span><span class="o">(</span><span class="s">", "</span><span class="o">,</span> <span class="s">"["</span><span class="o">,</span> <span class="s">"]"</span><span class="o">));</span>
</code></pre></div></div>

<p>Метод <code class="language-plaintext highlighter-rouge">joiner()</code> может иметь от одного до трех параметров (разделитель, префикс, суффикс). Самое удобное в использовании <code class="language-plaintext highlighter-rouge">joiner()</code> заключается в том, что разработчику не нужно проверять, достигает ли поток своего конца, чтобы применить суффикс, а не разделитель. Коллектор позаботится об этом.</p>

<p>Обработка среднего значения всех числовых элементов потока:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="n">averagePrice</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">averagingInt</span><span class="o">(</span><span class="nl">Product:</span><span class="o">:</span><span class="n">getPrice</span><span class="o">));</span>
</code></pre></div></div>

<p>Обработка суммы всех числовых элементов потока:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">summingPrice</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">summingInt</span><span class="o">(</span><span class="nl">Product:</span><span class="o">:</span><span class="n">getPrice</span><span class="o">));</span>
</code></pre></div></div>

<p>Методы <code class="language-plaintext highlighter-rouge">averagingXX()</code>, <code class="language-plaintext highlighter-rouge">summingXX()</code> и <code class="language-plaintext highlighter-rouge">summarizingXX()</code> могут работать с примитивами (int, long, double) и с их классами-оболочками (Integer, Long, Double). Еще одной мощной функцией этих методов является обеспечение маппинга. В результате разработчику не нужно использовать дополнительную операцию <code class="language-plaintext highlighter-rouge">map()</code> перед методом <code class="language-plaintext highlighter-rouge">collect()</code>.</p>

<p>Сбор статистической информации об элементах stream:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IntSummaryStatistics</span> <span class="n">statistics</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">summarizingInt</span><span class="o">(</span><span class="nl">Product:</span><span class="o">:</span><span class="n">getPrice</span><span class="o">));</span>
</code></pre></div></div>

<p>Используя результирующий экземпляр типа IntSummaryStatistics, разработчик может создать статистический отчет, применив метод <code class="language-plaintext highlighter-rouge">toString()</code>. Результатом будет строка, похожая на “IntSummaryStatistics{count=5, sum=86, min=13, average=17200000, max=23}.”</p>

<p>Также легко извлечь из этого объекта отдельные значения для count, sum, min, и average, применив методы <code class="language-plaintext highlighter-rouge">getCount()</code>, <code class="language-plaintext highlighter-rouge">getSum()</code>, <code class="language-plaintext highlighter-rouge">getMin()</code>, <code class="language-plaintext highlighter-rouge">getAverage()</code>, и <code class="language-plaintext highlighter-rouge">getMax()</code>. Все эти значения могут быть извлечены из одного конвейера.</p>

<p>Группировка элементов stream в соответствии с указанной функцией:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;&gt;</span> <span class="n">collectorMapOfLists</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">groupingBy</span><span class="o">(</span><span class="nl">Product:</span><span class="o">:</span><span class="n">getPrice</span><span class="o">));</span>
</code></pre></div></div>

<p>В приведенном выше примере поток был сведен к Map, который группирует все продукты по их цене.</p>

<p>Разделение элементов stream на группы в соответствии с некоторым предикатом:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Boolean</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;&gt;</span> <span class="n">mapPartioned</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">partitioningBy</span><span class="o">(</span><span class="n">element</span> <span class="o">-&gt;</span> <span class="n">element</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">15</span><span class="o">));</span>
</code></pre></div></div>

<p>Этот код использует потоки данных (Streams) для разделения списка продуктов (productList) на две группы на основе цены продукта. Результатом будет Map, где ключами являются Boolean значения (true или false), а значениями — списки продуктов, соответствующие этим ключам.</p>

<p>Приведение коллектора к дополнительному преобразованию:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">unmodifiableSet</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
  <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">collectingAndThen</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toSet</span><span class="o">(),</span>
  <span class="nl">Collections:</span><span class="o">:</span><span class="n">unmodifiableSet</span><span class="o">));</span>
</code></pre></div></div>

<p>В данном конкретном случае сборщик преобразовал stream в Set, а затем создал из него неизменяемый Set.</p>

<p>Кастомный сборщик:</p>

<p>Если по какой-либо причине необходимо создать кастомный коллектор, самый простой и наименее подробный способ сделать это - использовать метод <code class="language-plaintext highlighter-rouge">of()</code> типа Collector.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Collector</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">,</span> <span class="o">?,</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;&gt;</span> <span class="n">toLinkedList</span> <span class="o">=</span>
  <span class="nc">Collector</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="nl">LinkedList:</span><span class="o">:</span><span class="k">new</span><span class="o">,</span> <span class="nl">LinkedList:</span><span class="o">:</span><span class="n">add</span><span class="o">,</span>
    <span class="o">(</span><span class="n">first</span><span class="o">,</span> <span class="n">second</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
       <span class="n">first</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">second</span><span class="o">);</span>
       <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">});</span>

<span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">linkedListOfPersons</span> <span class="o">=</span>
  <span class="n">productList</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span><span class="n">toLinkedList</span><span class="o">);</span>
</code></pre></div></div>

<p>Метод <code class="language-plaintext highlighter-rouge">of()</code> используется для создания экземпляра Collector. Первым аргументом является функция, которая создает аккумулятор (в нашем случае, новый LinkedList). Вторым аргументом — функция, которая добавляет элемент в аккумулятор. Третий аргумент — функция, объединяющая два аккумулятора в один. В данном случае, она просто добавляет все элементы из второго аккумулятора в первый. В этом примере экземпляр коллектора был объединен в <code class="language-plaintext highlighter-rouge">LinkedList&lt;Product&gt;</code>.</p>

<h2 id="7-параллельные-потоки">7. Параллельные потоки</h2>

<p>До появления Java 8 распараллеливание было сложным. Появление ExecutorService и forkJoin немного упростило жизнь разработчику, но все же стоило запомнить, как создать конкретный исполнитель, как его запускать и так далее. В Java 8 представлен способ реализации параллелизма в функциональном стиле.</p>

<p>API позволяет нам создавать параллельные потоки, которые выполняют операции в параллельном режиме. Если источником потока является коллекция или массив, этого можно достичь с помощью метода <code class="language-plaintext highlighter-rouge">parallelStream()</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">streamOfCollection</span> <span class="o">=</span> <span class="n">productList</span><span class="o">.</span><span class="na">parallelStream</span><span class="o">();</span>
<span class="kt">boolean</span> <span class="n">isParallel</span> <span class="o">=</span> <span class="n">streamOfCollection</span><span class="o">.</span><span class="na">isParallel</span><span class="o">();</span>
<span class="kt">boolean</span> <span class="n">bigPrice</span> <span class="o">=</span> <span class="n">streamOfCollection</span>
  <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">product</span> <span class="o">-&gt;</span> <span class="n">product</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()</span> <span class="o">*</span> <span class="mi">12</span><span class="o">)</span>
  <span class="o">.</span><span class="na">anyMatch</span><span class="o">(</span><span class="n">price</span> <span class="o">-&gt;</span> <span class="n">price</span> <span class="o">&gt;</span> <span class="mi">200</span><span class="o">);</span>
</code></pre></div></div>

<p>Если источником потока является нечто иное, чем коллекция или массив, следует использовать метод <code class="language-plaintext highlighter-rouge">parallel()</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IntStream</span> <span class="n">intStreamParallel</span> <span class="o">=</span> <span class="nc">IntStream</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">150</span><span class="o">).</span><span class="na">parallel</span><span class="o">();</span>
<span class="kt">boolean</span> <span class="n">isParallel</span> <span class="o">=</span> <span class="n">intStreamParallel</span><span class="o">.</span><span class="na">isParallel</span><span class="o">();</span>
</code></pre></div></div>

<p>По сути, Stream API автоматически использует платформу forkJoin для параллельного выполнения операций. По умолчанию будет использоваться общий пул потоков.</p>

<p>При использовании потоков в параллельном режиме избегайте блокирования операций. Также лучше использовать параллельный режим, когда для выполнения задач требуется аналогичное количество времени. Если одна задача длится намного дольше другой, это может замедлить рабочий процесс всего приложения.</p>

<p>Поток в параллельном режиме может быть преобразован обратно в последовательный режим с помощью метода <code class="language-plaintext highlighter-rouge">sequential()</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IntStream</span> <span class="n">intStreamSequential</span> <span class="o">=</span> <span class="n">intStreamParallel</span><span class="o">.</span><span class="na">sequential</span><span class="o">();</span>
<span class="kt">boolean</span> <span class="n">isParallel</span> <span class="o">=</span> <span class="n">intStreamSequential</span><span class="o">.</span><span class="na">isParallel</span><span class="o">();</span>
</code></pre></div></div>

<h2 id="8-заключение">8. Заключение</h2>

<p>Stream API - это мощный, но простой для понимания набор инструментов для обработки последовательности элементов. При правильном использовании это позволяет нам сократить огромное количество шаблонного кода, создавать более читаемые программы и повышать производительность приложения.</p>

<p>В большинстве примеров кода, показанных в этой статье, мы оставили потоки неиспользованными (мы не применяли метод <code class="language-plaintext highlighter-rouge">close()</code> или терминальную операцию). В реальном приложении не оставляйте созданный поток неиспользованным, так как это приведет к утечке памяти.</p>

<p><a href="https://www.baeldung.com/java-8-streams">оригинал</a></p>]]></content><author><name>Ринат Мамбетов</name></author><category term="java" /><summary type="html"><![CDATA[В этом руководстве рассматривается практическое использование Java 8 Streams от создания до параллельного выполнения.]]></summary></entry></feed>